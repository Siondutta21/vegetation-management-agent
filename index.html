<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå≥ Vegetation Management Agent - Interactive Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/plotly.js-dist@2.24.1/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #27ae60;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            font-size: 14px;
            color: #7f8c8d;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #95a5a6;
            animation: pulse 2s infinite;
        }
        
        .api-status.connected .status-dot {
            background: #27ae60;
        }
        
        .api-status.disconnected .status-dot {
            background: #e74c3c;
        }

        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .main-content {
            margin-left: 320px;
            padding: 20px;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            overflow: hidden;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            background: transparent;
            font-size: 1em;
        }

        .tab.active {
            background: #3498db;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
        }

        .metric-label {
            font-size: 0.9em;
            color: #7f8c8d;
        }

        .map-container {
            height: 600px;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }

        .transmission-selector {
            margin-bottom: 20px;
        }

        .transmission-selector select {
            width: 100%;
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            font-size: 1em;
            background: white;
        }

        .filter-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .filter-controls select {
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .risk-level {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
        }

        .risk-level.risk-critical { 
            background: #e74c3c !important; 
            color: white !important;
            font-weight: bold !important;
        }
        .risk-level.risk-high { 
            background: #f39c12 !important; 
            color: white !important;
            font-weight: bold !important;
        }
        .risk-level.risk-medium { 
            background: #f1c40f !important; 
            color: #2c3e50 !important;
            font-weight: bold !important;
        }
        .risk-level.risk-low { 
            background: #27ae60 !important; 
            color: white !important;
            font-weight: bold !important;
        }
        .risk-level.risk-very-low { 
            background: #9b59b6 !important; 
            color: white !important;
            font-weight: bold !important;
        }

        .vegetation-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .vegetation-table th,
        .vegetation-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        .vegetation-table th {
            background: #3498db;
            color: white;
            font-weight: bold;
        }

        .vegetation-table tr:hover {
            background: rgba(52, 152, 219, 0.1);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success { background: #27ae60; }
        .notification.warning { background: #f39c12; }
        .notification.error { background: #e74c3c; }

        .line-details {
            background: rgba(52, 152, 219, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .line-details h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .line-details p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }
        
        .line-type-selector {
            margin-bottom: 25px;
            padding: 20px;
            background: #34495e;
            border-radius: 10px;
            border: 2px solid #3498db;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .line-type-selector label {
            display: block;
            margin-bottom: 15px;
            font-weight: bold;
            color: #ffffff;
            font-size: 16px;
        }
        
        .custom-dropdown {
            position: relative;
            width: 100%;
        }
        
        .enhanced-select {
            width: 100%;
            padding: 12px 15px;
            background: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 8px;
            color: #ffffff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            appearance: none;
            transition: all 0.3s ease;
        }
        
        .enhanced-select:hover {
            background: #34495e;
            border-color: #5dade2;
        }
        
        .enhanced-select:focus {
            outline: none;
            border-color: #5dade2;
            box-shadow: 0 0 0 2px rgba(93, 173, 226, 0.3);
        }
        
        .enhanced-select option {
            background: #2c3e50;
            color: #ffffff;
            padding: 8px;
            font-size: 14px;
        }
        
        .dropdown-arrow {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #ffffff;
            font-size: 12px;
            pointer-events: none;
        }
        
        .filter-controls {
            margin-bottom: 25px;
        }
        
        .filter-group {
            margin-bottom: 20px;
        }
        
        .filter-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #ffffff;
            font-size: 14px;
        }
        
        .line-selector {
            margin-bottom: 25px;
        }
        
        .line-selector label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #ffffff;
            font-size: 14px;
        }
        
        /* Enhanced sidebar styling */
        .sidebar {
            background: #2c3e50;
            border-right: 2px solid #3498db;
            box-shadow: 5px 0 25px rgba(0, 0, 0, 0.3);
        }
        
        .sidebar h3 {
            color: #ffffff;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 25px;
            text-align: center;
        }
        
        /* Enhanced button styling */
        .enhanced-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            font-size: 12px;
            flex: 1;
            margin: 0 4px;
        }
        
        .enhanced-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .btn-icon {
            font-size: 14px;
        }
        
        .btn-text {
            font-size: 12px;
            font-weight: 600;
        }
        
        /* Action buttons container */
        .action-buttons {
            margin-top: 15px;
            padding: 12px;
            background: #34495e;
            border-radius: 8px;
            border: 1px solid #3498db;
            display: flex;
            gap: 8px;
        }
        
        /* Enhanced line details */
        .line-details {
            background: #34495e;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #3498db;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .line-details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        
        .line-details-header h4 {
            margin: 0;
            color: #ffffff;
            font-size: 18px;
            font-weight: bold;
        }
        
        .line-type-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .line-type-badge.transmission {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .line-type-badge.distribution {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }
        
        .line-info-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .line-info-content p {
            margin: 0;
            padding: 10px 12px;
            background: #2c3e50;
            border-radius: 6px;
            border-left: 3px solid #3498db;
            font-size: 14px;
            color: #ffffff;
        }
        
        .line-info-content strong {
            color: #5dade2;
            font-weight: 600;
        }
        
        /* No data message styling */
        .no-data-message {
            text-align: center;
            padding: 40px 20px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            border: 2px dashed #3498db;
        }
        
        .no-data-message p {
            color: #ffffff;
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }
        
        /* Custom zoom controls styling */
        .custom-zoom-control {
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .custom-zoom-control a {
            display: block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            text-decoration: none;
            color: #333;
            background: white;
            border-bottom: 1px solid #ccc;
            transition: all 0.3s ease;
        }
        
        .custom-zoom-control a:hover {
            background: #f4f4f4;
            color: #000;
        }
        
        .custom-zoom-control a:last-child {
            border-bottom: none;
        }
        
        .leaflet-control-zoom-in,
        .leaflet-control-zoom-out,
        .leaflet-control-reset-view {
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Map container enhancements */
        .map-container {
            position: relative;
        }
        
        .map-controls-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .map-controls-overlay button {
            display: block;
            width: 100%;
            margin-bottom: 5px;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #3498db;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .map-controls-overlay button:hover {
            background: #2980b9;
        }
        
        .map-controls-overlay button:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h3>üìã Power Line Selection</h3>
        
        <!-- KML File Upload Section -->
        <div class="kml-upload-section" style="margin-bottom: 25px; padding: 20px; background: #34495e; border-radius: 10px; border: 2px solid #3498db;">
            <h4 style="color: #ffffff; margin-bottom: 15px; font-size: 16px;">üó∫Ô∏è Upload KML File</h4>
            <div style="margin-bottom: 15px;">
                <input type="file" id="kml-file-input" accept=".kml" style="display: none;" onchange="handleKMLUpload(event)">
                <button onclick="document.getElementById('kml-file-input').click()" style="width: 100%; padding: 10px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                    üìÅ Choose KML File
                </button>
            </div>
            <div style="margin-bottom: 10px;">
                <button onclick="testKMLProcessing()" style="width: 100%; padding: 8px; background: #e67e22; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    üß™ Test KML Processing
                </button>
            </div>
            <div id="kml-upload-status" style="color: #ffffff; font-size: 12px; text-align: center;"></div>
            <div id="kml-file-info" style="margin-top: 10px; padding: 10px; background: #2c3e50; border-radius: 6px; display: none;">
                <div style="color: #5dade2; font-weight: bold; margin-bottom: 5px;">üìä File Info:</div>
                <div id="kml-file-details" style="color: #ffffff; font-size: 11px;"></div>
            </div>
        </div>
        
        <div class="line-type-selector">
            <label>Line Type:</label>
            <div class="custom-dropdown">
                <select id="line-type-select" onchange="switchLineType()" class="enhanced-select">
                    <option value="transmission" selected>‚ö° Transmission Lines</option>
                    <option value="distribution">üîå Distribution Lines</option>
                </select>
                <div class="dropdown-arrow">‚ñº</div>
            </div>
        </div>
        
        <div class="filter-controls">
            <div class="filter-group">
                <label>‚ö° Voltage Level</label>
                <div class="custom-dropdown">
                    <select id="voltage-filter" onchange="filterLines()" class="enhanced-select">
                        <option value="">üåê All Voltage Levels</option>
                        <option value="69kV">‚ö° 69kV</option>
                        <option value="115kV">‚ö° 115kV</option>
                        <option value="230kV">‚ö° 230kV</option>
                        <option value="345kV">‚ö° 345kV</option>
                        <option value="500kV">‚ö° 500kV</option>
                        <option value="765kV">‚ö° 765kV</option>
                        <option value="11kV">üîå 11kV</option>
                        <option value="22kV">üîå 22kV</option>
                        <option value="33kV">üîå 33kV</option>
                        <option value="66kV">üîå 66kV</option>
                        <option value="110kV">üîå 110kV</option>
                        <option value="132kV">üîå 132kV</option>
                    </select>
                    <div class="dropdown-arrow">‚ñº</div>
                </div>
            </div>
            
            <div class="filter-group">
                <label>üó∫Ô∏è Region</label>
                <div class="custom-dropdown">
                    <select id="region-filter" onchange="filterLines()" class="enhanced-select">
                        <option value="">üåç All Regions</option>
                        <option value="Northern California">üèîÔ∏è Northern California</option>
                        <option value="Southern California">üå¥ Southern California</option>
                        <option value="Central Valley">üåæ Central Valley</option>
                        <option value="Sierra Nevada">‚õ∞Ô∏è Sierra Nevada</option>
                        <option value="Coastal Region">üåä Coastal Region</option>
                        <option value="Bay Area">üåâ Bay Area</option>
                        <option value="Sacramento Valley">üèõÔ∏è Sacramento Valley</option>
                        <option value="San Joaquin Valley">üåæ San Joaquin Valley</option>
                        <option value="Mountain Region">üèîÔ∏è Mountain Region</option>
                        <option value="Desert Region">üèúÔ∏è Desert Region</option>
                    </select>
                    <div class="dropdown-arrow">‚ñº</div>
                </div>
            </div>
        </div>
        
        <div class="line-selector">
            <label>üîó Power Line</label>
            <div class="custom-dropdown">
                <select id="line-select" onchange="selectLine()" class="enhanced-select">
                    <option value="">üìã Select Power Line</option>
                </select>
                <div class="dropdown-arrow">‚ñº</div>
            </div>
        </div>
        
        <div class="action-buttons" style="margin-top: 20px;">
            <button class="btn btn-primary enhanced-btn" onclick="generateRiskReport()">
                <span class="btn-icon">üìä</span>
                <span class="btn-text">Report Generator</span>
            </button>
            <button class="btn btn-warning enhanced-btn" onclick="generatePDFReport()">
                <span class="btn-icon">üìÑ</span>
                <span class="btn-text">Export PDF</span>
            </button>
        </div>
        
        <div id="risk-summary" style="margin-top: 20px;">
            <h4>‚ö†Ô∏è Risk Summary</h4>
            <div id="risk-metrics"></div>
        </div>
    </div>

    <div class="main-content">
        <div class="header">
                            <h1>üå≥ Vegetation Management Agent <span class="status-indicator"></span></h1>
                <div id="api-status" class="api-status">
                    <span class="status-dot"></span>
                    <span class="status-text">Checking API...</span>
                </div>
            <p>Real-time vegetation risk analysis and transmission line management</p>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('overview')">üìä Overview</button>
            <button class="tab" onclick="showTab('vegetation')">üå≥ Vegetation Analysis</button>
            <button class="tab" onclick="showTab('risk')">‚ö†Ô∏è Risk Assessment</button>
            <button class="tab" onclick="showTab('growth')">üìà Growth Prediction</button>
            <button class="tab" onclick="showTab('map')">üó∫Ô∏è Interactive Map</button>
        </div>

        <!-- Overview Tab -->
        <div id="overview" class="tab-content active">
            <div class="dashboard-grid">
                <div class="card">
                    <h3>üìà System Overview</h3>
                    <div class="metric">
                        <div>
                            <div class="metric-value" id="total-lines">100</div>
                            <div class="metric-label" id="total-lines-label">Total Transmission Lines</div>
                        </div>
                        <div style="color: #27ae60;">Active</div>
                    </div>
                    <div class="metric">
                        <div>
                            <div class="metric-value" id="total-vegetation">1,247</div>
                            <div class="metric-label">Vegetation Points</div>
                        </div>
                        <div style="color: #f39c12;">+12%</div>
                    </div>
                    <div class="metric">
                        <div>
                            <div class="metric-value" id="critical-risks">23</div>
                            <div class="metric-label">Critical Risks</div>
                        </div>
                        <div style="color: #e74c3c;">+5%</div>
                    </div>
                    <div class="metric">
                        <div>
                            <div class="metric-value" id="avg-risk">0.45</div>
                            <div class="metric-label">Avg Risk Score</div>
                        </div>
                        <div style="color: #27ae60;">-2%</div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìä Risk Distribution</h3>
                    <div class="chart-container">
                        <canvas id="riskDistributionChart"></canvas>
                    </div>
                </div>

                <div class="card">
                    <h3>üå≥ Vegetation Types</h3>
                    <div class="chart-container">
                        <canvas id="vegetationTypeChart"></canvas>
                    </div>
                </div>

                <div class="card">
                    <h3>üìà Growth Trends</h3>
                    <div class="chart-container">
                        <canvas id="growthTrendChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Vegetation Analysis Tab -->
        <div id="vegetation" class="tab-content">
            <div class="dashboard-grid">
                <div class="card">
                    <h3>üå≥ Vegetation Analysis</h3>
                    <div id="vegetation-analysis-content">
                        <div class="loading">
                            <div class="spinner"></div>
                            <p>Loading vegetation data...</p>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìã Line Details</h3>
                    <div id="line-details" class="line-details" style="display: none;">
                        <div class="line-details-header">
                            <h4>üìã Line Details</h4>
                            <div class="line-type-badge" id="line-type-badge"></div>
                        </div>
                        <div id="line-info" class="line-info-content"></div>
                    </div>
                    <div id="distance-analysis-content">
                        <div class="loading">
                            <div class="spinner"></div>
                            <p>Select a power line to view details...</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3>üìã Vegetation Details</h3>
                <div id="vegetation-table-container">
                    <table class="vegetation-table" id="vegetation-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Type</th>
                                <th>Height (m)</th>
                                <th>Distance (m)</th>
                                <th>Risk Level</th>
                                <th>Growth Rate</th>
                                <th>Health</th>
                                <th>Priority</th>
                            </tr>
                        </thead>
                        <tbody id="vegetation-table-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Risk Assessment Tab -->
        <div id="risk" class="tab-content">
            <div class="dashboard-grid">
                <div class="card">
                    <h3>‚ö†Ô∏è Risk Assessment</h3>
                    <div id="risk-assessment-content">
                        <div class="loading">
                            <div class="spinner"></div>
                            <p>Analyzing risks...</p>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3>üö® High-Risk Vegetation</h3>
                <div id="high-risk-vegetation">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Identifying high-risk vegetation...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Growth Prediction Tab -->
        <div id="growth" class="tab-content">
            <div class="dashboard-grid">
                <div class="card">
                    <h3>üìà Growth Prediction</h3>
                    <div id="growth-prediction-content">
                        <div class="loading">
                            <div class="spinner"></div>
                            <p>Predicting growth patterns...</p>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìÖ Maintenance Schedule</h3>
                    <div id="maintenance-schedule-content">
                        <div class="loading">
                            <div class="spinner"></div>
                            <p>Generating maintenance schedule...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Interactive Map Tab -->
        <div id="map" class="tab-content">
            <div class="card">
                <h3>üó∫Ô∏è Interactive Map</h3>
                <div style="margin-bottom: 10px;">
                    <button onclick="refreshMap()" style="padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        üîÑ Refresh Map
                    </button>
                    <button onclick="exportMapImage()" style="padding: 8px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">
                        üì∏ Export Map
                    </button>
                    <button onclick="resetMapView()" style="padding: 8px 16px; background: #9b59b6; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">
                        üè† Reset View
                    </button>
                    <button onclick="zoomToFit()" style="padding: 8px 16px; background: #e67e22; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">
                        üîç Fit to View
                    </button>
                </div>
                <div id="interactive-map" class="map-container">
                    <div class="map-controls-overlay">
                        <button onclick="map.zoomIn()" title="Zoom In">üîç+</button>
                        <button onclick="map.zoomOut()" title="Zoom Out">üîç-</button>
                        <button onclick="resetMapView()" title="Reset View">üè†</button>
                        <button onclick="zoomToFit()" title="Fit to Content">üìê</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        // Global variables
        let transmissionLines = [];
        let distributionLines = [];
        let vegetationData = [];
        let selectedLineId = null;
        let currentLineType = 'transmission';
        let map = null;
        let charts = {};
        let uploadedKMLData = null;
        let apiBaseUrl = 'http://localhost:8000';
// For sharing, you can change this to your deployed backend URL
// let apiBaseUrl = 'https://your-app-name.herokuapp.com';
// let apiBaseUrl = 'https://your-app-name.railway.app';
// let apiBaseUrl = 'https://your-app-name.onrender.com';
        let isApiConnected = false;

        // API Integration Functions
        async function checkApiConnection() {
            const statusElement = document.getElementById('api-status');
            const statusDot = statusElement?.querySelector('.status-dot');
            const statusText = statusElement?.querySelector('.status-text');
            
            try {
                // Create a timeout promise
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout')), 5000);
                });
                
                const fetchPromise = fetch(`${apiBaseUrl}/health`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const response = await Promise.race([fetchPromise, timeoutPromise]);
                
                if (response.ok) {
                    const data = await response.json();
                    isApiConnected = true;
                    console.log('‚úÖ API connected:', data);
                    
                    if (statusElement) {
                        statusElement.className = 'api-status connected';
                        statusText.textContent = 'Python AI Backend Connected';
                    }
                    
                    showNotification('üöÄ Python AI backend connected successfully!', 'success');
                    return true;
                } else {
                    isApiConnected = false;
                    console.log('‚ùå API not available');
                    
                    if (statusElement) {
                        statusElement.className = 'api-status disconnected';
                        statusText.textContent = 'Python Backend Unavailable';
                    }
                    
                    return false;
                }
            } catch (error) {
                isApiConnected = false;
                console.log('‚ùå API connection failed:', error);
                
                if (statusElement) {
                    statusElement.className = 'api-status disconnected';
                    statusText.textContent = 'Python Backend Unavailable';
                }
                
                return false;
            }
        }

        async function callPythonAPI(endpoint, data = null) {
            if (!isApiConnected) {
                console.log('‚ö†Ô∏è API not connected, using fallback data');
                return null;
            }

            try {
                // Create a timeout promise
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout')), 10000);
                });
                
                const fetchPromise = fetch(`${apiBaseUrl}/${endpoint}`, {
                    method: data ? 'POST' : 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: data ? JSON.stringify(data) : undefined
                });
                
                const response = await Promise.race([fetchPromise, timeoutPromise]);
                
                if (response.ok) {
                    return await response.json();
                } else {
                    console.error(`API call failed: ${response.status}`);
                    return null;
                }
            } catch (error) {
                console.error('API call error:', error);
                return null;
            }
        }

        async function getVegetationAnalysis(lineId, lineData) {
            console.log('üîç Attempting API vegetation analysis for:', lineId);
            
            try {
            const apiData = await callPythonAPI('detect_vegetation', {
                line_id: lineId,
                line_data: lineData,
                coordinates: lineData.coordinates || [],
                line_type: currentLineType
            });
            
                if (apiData && apiData.vegetation_data && Array.isArray(apiData.vegetation_data)) {
                console.log('‚úÖ API vegetation analysis successful:', apiData.vegetation_data.length, 'points');
                return apiData.vegetation_data;
                } else {
                    console.log('‚ö†Ô∏è API returned invalid data, using fallback');
                    return generateVegetationData(lineId);
            }
            } catch (error) {
                console.error('Error in getVegetationAnalysis:', error);
            console.log('‚ö†Ô∏è API vegetation analysis failed, using fallback');
            return generateVegetationData(lineId);
            }
        }

        async function getRiskAssessment(vegetationData) {
            try {
            const apiData = await callPythonAPI('assess_risk', {
                vegetation_data: vegetationData,
                line_type: currentLineType
            });
            
            if (apiData && apiData.risk_analysis) {
                return apiData.risk_analysis;
                } else {
                    console.log('‚ö†Ô∏è API returned invalid risk data, using fallback');
                    return calculateRiskAssessment(vegetationData);
            }
            } catch (error) {
                console.error('Error in getRiskAssessment:', error);
                console.log('‚ö†Ô∏è API risk assessment failed, using fallback');
            return calculateRiskAssessment(vegetationData);
            }
        }

        async function getGrowthPrediction(vegetationData) {
            try {
            const apiData = await callPythonAPI('predict_growth', {
                vegetation_data: vegetationData,
                line_type: currentLineType
            });
            
            if (apiData && apiData.growth_prediction) {
                return apiData.growth_prediction;
                } else {
                    console.log('‚ö†Ô∏è API returned invalid growth data, using fallback');
                    return generateGrowthPrediction(vegetationData);
            }
            } catch (error) {
                console.error('Error in getGrowthPrediction:', error);
                console.log('‚ö†Ô∏è API growth prediction failed, using fallback');
            return generateGrowthPrediction(vegetationData);
            }
        }

        function calculateRiskAssessment(vegetationData) {
            // Local fallback risk calculation
            const criticalRisks = vegetationData.filter(v => v.riskLevel === 'Critical').length;
            const highRisks = vegetationData.filter(v => v.riskLevel === 'High').length;
            const mediumRisks = vegetationData.filter(v => v.riskLevel === 'Medium').length;
            const lowRisks = vegetationData.filter(v => v.riskLevel === 'Low').length;
            const veryLowRisks = vegetationData.filter(v => v.riskLevel === 'Very Low').length;
            
            const totalCost = vegetationData.reduce((sum, v) => sum + v.estimatedCost, 0);
            const avgRiskScore = vegetationData.reduce((sum, v) => sum + v.riskScore, 0) / vegetationData.length;
            
            return {
                critical_risks: criticalRisks,
                high_risks: highRisks,
                medium_risks: mediumRisks,
                low_risks: lowRisks,
                very_low_risks: veryLowRisks,
                total_cost: totalCost,
                average_risk_score: avgRiskScore,
                risk_distribution: {
                    critical: criticalRisks,
                    high: highRisks,
                    medium: mediumRisks,
                    low: lowRisks,
                    very_low: veryLowRisks
                }
            };
        }

        function generateGrowthPrediction(vegetationData) {
            // Local fallback growth prediction
            const predictions = [];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            for (let month of months) {
                predictions.push({
                    month: month,
                    growth_rate: Math.random() * 0.3 + 0.1,
                    risk_increase: Math.random() * 0.2 + 0.05,
                    maintenance_needed: Math.random() > 0.7
                });
            }
            
            return {
                predictions: predictions,
                total_growth: predictions.reduce((sum, p) => sum + p.growth_rate, 0),
                maintenance_schedule: predictions.filter(p => p.maintenance_needed).map(p => p.month)
            };
        }

        // KML File Upload and Parsing Functions
        function handleKMLUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const statusDiv = document.getElementById('kml-upload-status');
            const fileInfoDiv = document.getElementById('kml-file-info');
            const fileDetailsDiv = document.getElementById('kml-file-details');
            
            // Validate file type
            if (!file.name.toLowerCase().endsWith('.kml')) {
                statusDiv.textContent = '‚ùå Please select a valid KML file (.kml)';
                showNotification('Please select a valid KML file with .kml extension.', 'error');
                return;
            }
            
            statusDiv.textContent = 'üìñ Reading KML file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const kmlContent = e.target.result;
                    
                    // Validate KML content
                    if (!kmlContent.includes('<kml') || !kmlContent.includes('<Placemark')) {
                        statusDiv.textContent = '‚ùå Invalid KML file format';
                        showNotification('Invalid KML file format. Please check the file content.', 'error');
                        return;
                    }
                    
                    // Use Python API to process KML and get map configuration
                    processKMLWithPythonAPI(kmlContent, file.name);
                    
                } catch (error) {
                    statusDiv.textContent = '‚ùå Error parsing KML file';
                    console.error('KML parsing error:', error);
                    showNotification('Error parsing KML file. Please check the file format.', 'error');
                }
            };
            
            reader.onerror = function() {
                statusDiv.textContent = '‚ùå Error reading file';
                showNotification('Error reading KML file. Please try again.', 'error');
            };
            
            reader.readAsText(file);
        }
        
        // Process KML using Python API
        async function processKMLWithPythonAPI(kmlContent, fileName) {
            const statusDiv = document.getElementById('kml-upload-status');
            const fileInfoDiv = document.getElementById('kml-file-info');
            const fileDetailsDiv = document.getElementById('kml-file-details');
            
            try {
                statusDiv.textContent = 'üîç Processing KML with Python API...';
                console.log('üîç Starting KML processing for:', fileName);
                console.log('üîç API Base URL:', apiBaseUrl);
                
                // Call Python API to process KML
                const response = await fetch(`${apiBaseUrl}/process_kml`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        kml_content: kmlContent
                    })
                });
                
                console.log('üîç API Response status:', response.status);
                console.log('üîç API Response ok:', response.ok);
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status} - ${response.statusText}`);
                }
                
                const result = await response.json();
                console.log('üîç API Response result:', result);
                
                if (result.success) {
                    // Update UI with results
                    statusDiv.textContent = `‚úÖ Successfully processed KML file`;
                    fileInfoDiv.style.display = 'block';
                    fileDetailsDiv.innerHTML = `
                        <div>üìÅ File: ${fileName}</div>
                        <div>üìç Lines: ${result.total_lines}</div>
                        <div>üó∫Ô∏è Coordinates: ${result.total_coordinates}</div>
                        <div>üéØ Center: ${result.map_config.center_lat.toFixed(4)}, ${result.map_config.center_lon.toFixed(4)}</div>
                        <div>üîç Zoom Level: ${result.map_config.zoom_level}</div>
                        <div style="margin-top: 10px;">
                            <button onclick="applyMapZoom('${fileName}')" class="btn btn-sm btn-primary">
                                üó∫Ô∏è Apply Map Zoom
                            </button>
                            <button onclick="refreshMapView()" class="btn btn-sm btn-primary" style="margin-left: 5px;">
                                üîÑ Refresh Map View
                            </button>
                            <button onclick="clearKMLData()" class="btn btn-sm btn-secondary" style="margin-left: 5px;">
                                üóëÔ∏è Clear KML Data
                            </button>
                        </div>
                    `;
                    
                    // Store the processed data
                    uploadedKMLData = {
                        lines: result.lines_data,
                        mapConfig: result.map_config,
                        fileName: fileName,
                        totalLines: result.total_lines,
                        totalCoordinates: result.total_coordinates
                    };
                    
                    console.log('üîç KML data stored:', uploadedKMLData);
                    
                    // Update line data - map Python API response to expected format
                    const mappedLines = result.lines_data.map((line, index) => ({
                        id: line.id || `KML_${index + 1}`,
                        name: line.name || `KML Line ${index + 1}`,
                        voltage: line.voltage || 'Unknown',
                        region: line.region || 'KML Import',
                        status: line.status || 'Active',
                        length: line.length || 1.0,
                        capacity: line.capacity || 100,
                        load: line.load || 50,
                        coordinates: line.coordinates || [],
                        startLat: line.start_lat || (line.coordinates && line.coordinates[0] ? line.coordinates[0].lat : 0),
                        startLon: line.start_lon || (line.coordinates && line.coordinates[0] ? line.coordinates[0].lon : 0),
                        endLat: line.end_lat || (line.coordinates && line.coordinates.length > 0 ? line.coordinates[line.coordinates.length - 1].lat : 0),
                        endLon: line.end_lon || (line.coordinates && line.coordinates.length > 0 ? line.coordinates[line.coordinates.length - 1].lon : 0)
                    }));
                    
                    console.log('üîç Mapped lines data:', mappedLines);
                    
                    updateLineDataFromKML({
                        lines: mappedLines,
                        lineType: 'transmission', // Default, will be determined by content
                        region: 'Detected'
                    });
                    
                    showNotification(`KML file processed successfully! Found ${result.total_lines} lines with ${result.total_coordinates} coordinates.`, 'success');
                    
                    // Automatically apply map zoom
                    setTimeout(() => {
                        applyMapZoom(fileName);
                    }, 1000);
                    
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
                
            } catch (error) {
                console.error('Python API error:', error);
                statusDiv.textContent = '‚ùå Error processing KML file';
                showNotification(`Error processing KML file: ${error.message}`, 'error');
                
                // Check if it's a network/API connection error
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.message.includes('timeout')) {
                    console.log('üîç Network/API connection error detected, using local fallback...');
                    showNotification('Python backend unavailable, using local KML processing...', 'warning');
                }
                
                // Fallback to local processing
                console.log('Falling back to local KML processing...');
                const parsedData = parseKMLFile(kmlContent);
                if (parsedData && parsedData.lines.length > 0) {
                    // Ensure fallback data has proper structure
                    const mappedFallbackLines = parsedData.lines.map((line, index) => ({
                        id: line.id || `KML_Fallback_${index + 1}`,
                        name: line.name || `KML Line ${index + 1}`,
                        voltage: line.voltage || 'Unknown',
                        region: line.region || 'KML Import',
                        status: line.status || 'Active',
                        length: line.length || 1.0,
                        capacity: line.capacity || 100,
                        load: line.load || 50,
                        coordinates: line.coordinates || [],
                        startLat: line.startLat || (line.coordinates && line.coordinates[0] ? line.coordinates[0].lat : 0),
                        startLon: line.startLon || (line.coordinates && line.coordinates[0] ? line.coordinates[0].lon : 0),
                        endLat: line.endLat || (line.coordinates && line.coordinates.length > 0 ? line.coordinates[line.coordinates.length - 1].lat : 0),
                        endLon: line.endLon || (line.coordinates && line.coordinates.length > 0 ? line.coordinates[line.coordinates.length - 1].lon : 0)
                    }));
                    
                    // Create map configuration for fallback data
                    const fallbackMapConfig = createMapConfigFromLines(mappedFallbackLines);
                    
                    const mappedFallbackData = {
                        ...parsedData,
                        lines: mappedFallbackLines,
                        mapConfig: fallbackMapConfig
                    };
                    
                    uploadedKMLData = mappedFallbackData;
                    console.log('üîç KML data stored (fallback):', uploadedKMLData);
                    updateLineDataFromKML(mappedFallbackData);
                    statusDiv.textContent = `‚úÖ Processed with fallback (${parsedData.lines.length} lines)`;
                    showNotification('KML processed with fallback method.', 'warning');
                    
                    // Automatically apply map zoom with fallback data
                    setTimeout(() => {
                        applyMapZoom(fileName);
                    }, 1000);
                }
            }
        }
        
        // Create map configuration from lines data
        function createMapConfigFromLines(lines) {
            console.log('üîç createMapConfigFromLines called with:', lines);
            
            // Check if Leaflet is available
            if (typeof L === 'undefined') {
                console.error('‚ùå Leaflet library not loaded!');
                showNotification('Leaflet library not loaded. Please refresh the page.', 'error');
                return null;
            }
            
            if (!lines || lines.length === 0) {
                console.log('‚ùå No lines provided');
                return null;
            }
            
            try {
                // Calculate bounds for all lines
                const bounds = L.latLngBounds();
                console.log('üîç Created bounds object:', bounds);
                
                let validCoordinatesFound = false;
                
                lines.forEach((line, lineIndex) => {
                    console.log(`üîç Processing line ${lineIndex}:`, line);
                    
                    if (line.coordinates && line.coordinates.length > 0) {
                        console.log(`üîç Line ${lineIndex} has ${line.coordinates.length} coordinates`);
                        
                        // Add all coordinates to bounds
                        line.coordinates.forEach((coord, coordIndex) => {
                            console.log(`üîç Coordinate ${coordIndex}:`, coord);
                            
                            if (coord.lat && coord.lon && !isNaN(coord.lat) && !isNaN(coord.lon)) {
                                console.log(`üîç Valid coordinate: [${coord.lat}, ${coord.lon}]`);
                                bounds.extend([coord.lat, coord.lon]);
                                validCoordinatesFound = true;
                            } else {
                                console.log(`‚ùå Invalid coordinate:`, coord);
                            }
                        });
                    } else if (line.startLat && line.startLon && line.endLat && line.endLon) {
                        console.log(`üîç Line ${lineIndex} has start/end points:`, {
                            start: [line.startLat, line.startLon],
                            end: [line.endLat, line.endLon]
                        });
                        
                        // Add start and end points to bounds
                        if (!isNaN(line.startLat) && !isNaN(line.startLon)) {
                            console.log(`üîç Valid start point: [${line.startLat}, ${line.startLon}]`);
                            bounds.extend([line.startLat, line.startLon]);
                            validCoordinatesFound = true;
                        } else {
                            console.log(`‚ùå Invalid start point:`, [line.startLat, line.startLon]);
                        }
                        
                        if (!isNaN(line.endLat) && !isNaN(line.endLon)) {
                            console.log(`üîç Valid end point: [${line.endLat}, ${line.endLon}]`);
                            bounds.extend([line.endLat, line.endLon]);
                            validCoordinatesFound = true;
                        } else {
                            console.log(`‚ùå Invalid end point:`, [line.endLat, line.endLon]);
                        }
                    } else {
                        console.log(`‚ùå Line ${lineIndex} has no valid coordinates or start/end points`);
                    }
                });
                
                console.log('üîç Valid coordinates found:', validCoordinatesFound);
                console.log('üîç Bounds object:', bounds);
                console.log('üîç Bounds empty:', bounds.isEmpty());
                
                if (!bounds.isEmpty()) {
                    const center = bounds.getCenter();
                    const zoom = calculateOptimalZoom(bounds);
                    
                    console.log('üîç Calculated center:', center);
                    console.log('üîç Calculated zoom:', zoom);
                    
                    const mapConfig = {
                        center_lat: center.lat,
                        center_lon: center.lng,
                        zoom_level: zoom
                    };
                    
                    console.log('‚úÖ Created map config:', mapConfig);
                    return mapConfig;
                } else {
                    console.log('‚ùå Bounds are empty, cannot create map config');
                    return null;
                }
                
            } catch (error) {
                console.error('‚ùå Error creating map config:', error);
                console.error('‚ùå Error stack:', error.stack);
                return null;
            }
        }
        
        // Test KML processing functionality
        async function testKMLProcessing() {
            console.log('üß™ Testing KML processing...');
            
            // Test API connection
            try {
                const response = await fetch(`${apiBaseUrl}/health`);
                if (response.ok) {
                    console.log('‚úÖ API is accessible');
                    showNotification('‚úÖ Python backend is accessible', 'success');
                } else {
                    console.log('‚ö†Ô∏è API returned error status:', response.status);
                    showNotification('‚ö†Ô∏è Python backend returned error status', 'warning');
                }
            } catch (error) {
                console.log('‚ùå API connection failed:', error);
                showNotification('‚ùå Python backend connection failed - will use local processing', 'warning');
            }
            
            // Test local KML parsing
            try {
                const testKML = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <Placemark>
      <name>Test Line</name>
      <LineString>
        <coordinates>-122.4194,37.7749 -122.4184,37.7759</coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>`;
                
                const parsedData = parseKMLFile(testKML);
                if (parsedData && parsedData.lines && parsedData.lines.length > 0) {
                    console.log('‚úÖ Local KML parsing works:', parsedData);
                    showNotification('‚úÖ Local KML parsing is working', 'success');
                } else {
                    console.log('‚ùå Local KML parsing failed');
                    showNotification('‚ùå Local KML parsing failed', 'error');
                }
            } catch (error) {
                console.log('‚ùå Local KML parsing error:', error);
                showNotification('‚ùå Local KML parsing error: ' + error.message, 'error');
            }
        }
        
        // Calculate optimal zoom level based on bounds
        function calculateOptimalZoom(bounds) {
            if (!bounds || bounds.isEmpty()) {
                return 10; // Default zoom
            }
            
            try {
                const latDiff = Math.abs(bounds.getNorth() - bounds.getSouth());
                const lonDiff = Math.abs(bounds.getEast() - bounds.getWest());
                const maxDiff = Math.max(latDiff, lonDiff);
                
                // Calculate zoom level based on span
                if (maxDiff > 10) return 5;      // Very wide view
                if (maxDiff > 5) return 6;       // Wide view
                if (maxDiff > 2) return 7;       // Medium-wide view
                if (maxDiff > 1) return 8;       // Medium view
                if (maxDiff > 0.5) return 9;     // Medium-close view
                if (maxDiff > 0.2) return 10;    // Close view
                if (maxDiff > 0.1) return 11;    // Very close view
                if (maxDiff > 0.05) return 12;   // Detail view
                return 13;                        // Very detailed view
            } catch (error) {
                console.error('Error calculating zoom:', error);
                return 10; // Default zoom
            }
        }
        
        // Create simple map configuration as fallback
        function createSimpleMapConfig(lines) {
            console.log('üîç createSimpleMapConfig called with:', lines);
            
            if (!lines || lines.length === 0) {
                console.log('‚ùå No lines for simple config');
                return null;
            }
            
            try {
                // Find any valid coordinates
                let validLat = null;
                let validLon = null;
                
                for (let line of lines) {
                    if (line.coordinates && line.coordinates.length > 0) {
                        for (let coord of line.coordinates) {
                            if (coord.lat && coord.lon && !isNaN(coord.lat) && !isNaN(coord.lon)) {
                                validLat = coord.lat;
                                validLon = coord.lon;
                                break;
                            }
                        }
                    } else if (line.startLat && line.startLon && !isNaN(line.startLat) && !isNaN(line.startLon)) {
                        validLat = line.startLat;
                        validLon = line.startLon;
                        break;
                    }
                    
                    if (validLat && validLon) break;
                }
                
                if (validLat && validLon) {
                    console.log('‚úÖ Found valid coordinates for simple config:', [validLat, validLon]);
                    return {
                        center_lat: validLat,
                        center_lon: validLon,
                        zoom_level: 12 // Default zoom level
                    };
                } else {
                    console.log('‚ùå No valid coordinates found for simple config');
                    return null;
                }
            } catch (error) {
                console.error('‚ùå Error in createSimpleMapConfig:', error);
                return null;
            }
        }
        
        // Apply map zoom using Python API results
        function applyMapZoom(fileName) {
            console.log('üó∫Ô∏è applyMapZoom called with fileName:', fileName);
            console.log('üó∫Ô∏è uploadedKMLData:', uploadedKMLData);
            
            if (!uploadedKMLData) {
                console.log('‚ùå No KML data available');
                showNotification('No KML data available. Please upload a KML file first.', 'warning');
                return;
            }
            
            console.log('üó∫Ô∏è KML data structure:', {
                hasLines: !!uploadedKMLData.lines,
                linesCount: uploadedKMLData.lines ? uploadedKMLData.lines.length : 0,
                hasMapConfig: !!uploadedKMLData.mapConfig,
                mapConfig: uploadedKMLData.mapConfig
            });
            
            // If no mapConfig but we have lines, create one
            if (!uploadedKMLData.mapConfig && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                console.log('üó∫Ô∏è Creating map configuration from KML lines...');
                console.log('üó∫Ô∏è Lines to process:', uploadedKMLData.lines);
                
                // Try complex map config creation first
                uploadedKMLData.mapConfig = createMapConfigFromLines(uploadedKMLData.lines);
                
                // If that fails, try simple fallback
                if (!uploadedKMLData.mapConfig) {
                    console.log('üó∫Ô∏è Complex map config failed, trying simple fallback...');
                    uploadedKMLData.mapConfig = createSimpleMapConfig(uploadedKMLData.lines);
                }
                
                console.log('üó∫Ô∏è Final mapConfig:', uploadedKMLData.mapConfig);
                
                if (!uploadedKMLData.mapConfig) {
                    console.log('‚ùå Could not create map configuration with any method');
                    showNotification('Could not create map configuration. Please try again.', 'error');
                    return;
                }
            }
            
            if (!uploadedKMLData.mapConfig) {
                console.log('‚ùå No map configuration available');
                showNotification('No map configuration available. Please upload a KML file first.', 'warning');
                return;
            }
            
            console.log('üó∫Ô∏è Applying map zoom from Python API...');
            
            const mapConfig = uploadedKMLData.mapConfig;
            
            if (map && mapConfig) {
                try {
                    // Validate map configuration data
                    if (typeof mapConfig.center_lat !== 'number' || typeof mapConfig.center_lon !== 'number' || typeof mapConfig.zoom_level !== 'number') {
                        throw new Error('Invalid map configuration: missing or invalid coordinates/zoom level');
                    }
                    
                    // Ensure map is properly initialized and has required methods
                    if (!isMapValid()) {
                        console.log('Map validation failed, reinitializing...');
                        updateMap();
                        setTimeout(() => applyMapZoom(fileName), 500);
                        return;
                    }
                    
                    if (!map._loaded) {
                        console.log('Map not fully loaded, reinitializing...');
                        updateMap();
                        setTimeout(() => applyMapZoom(fileName), 500);
                        return;
                    }
                    
                    // Set map center and zoom with animation
                    map.setView([mapConfig.center_lat, mapConfig.center_lon], mapConfig.zoom_level, {
                        animate: true,
                        duration: 1.0
                    });
                    
                    // Clear existing layers
                    clearMapLayers();
                    
                    // Add tile layer back
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap contributors'
                    }).addTo(map);
                    
                    // Add KML lines with red highlighting
                    if (uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                        try {
                            highlightAllKMLLines(uploadedKMLData.lines);
                        } catch (highlightError) {
                            console.warn('Warning: Could not highlight KML lines:', highlightError);
                            // Continue with zoom even if highlighting fails
                        }
                    }
                    
                    console.log(`‚úÖ Map zoomed to: ${mapConfig.center_lat}, ${mapConfig.center_lon}, zoom: ${mapConfig.zoom_level}`);
                    showNotification(`Map zoomed to KML location (${fileName})`, 'success');
                    
                    // Force map update
                    map.invalidateSize();
                    
                } catch (error) {
                    console.error('Error applying map zoom:', error);
                    showNotification(`Error applying map zoom: ${error.message}`, 'error');
                }
            } else {
                console.error('Map or map configuration not available');
                showNotification('Map not available. Please wait for map to load.', 'error');
            }
        }
        
        // Clear KML data and reset to default
        function clearKMLData() {
            console.log('üóëÔ∏è Clearing KML data...');
            
            // Clear global KML data
            uploadedKMLData = null;
            
            // Reload default transmission/distribution data
            loadTransmissionData();
            loadDistributionData();
            
            // Update UI
            updateVoltageOptions();
            populateLineSelector();
            updateOverviewMetrics();
            
            // Clear current selection
            selectedLineId = null;
            document.getElementById('line-details').style.display = 'none';
            
            // Clear KML file info from UI
            const fileInfoDiv = document.getElementById('kml-file-info');
            const fileDetailsDiv = document.getElementById('kml-file-details');
            const statusDiv = document.getElementById('kml-upload-status');
            
            if (fileInfoDiv) fileInfoDiv.style.display = 'none';
            if (fileDetailsDiv) fileDetailsDiv.innerHTML = '';
            if (statusDiv) statusDiv.textContent = 'No KML file loaded';
            
            // Update map to show default view
            updateMap();
            
            showNotification('KML data cleared successfully!', 'success');
        }
        
        // Reset map view to default
        function resetMapView() {
            if (map) {
                if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                    // Reset to KML view
                    zoomToKMLLocation(uploadedKMLData.lines);
                    showNotification('Map view reset to KML location', 'success');
                } else {
                    // Reset to default view
                    map.setView([37.7749, -122.4194], 10);
                    updateMap();
                    showNotification('Map view reset to default location', 'success');
                }
            }
        }
        
        // Zoom to fit all content
        function zoomToFit() {
            if (map) {
                if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                    // Fit to KML lines
                    zoomToKMLLocation(uploadedKMLData.lines);
                    showNotification('Map zoomed to fit KML content', 'success');
                } else if (selectedLineId) {
                    // Fit to selected line
                    const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                    const line = lines.find(l => l.id === selectedLineId);
                    if (line) {
                        const lineCoords = line.coordinates && line.coordinates.length > 0 ? 
                            line.coordinates.map(coord => [coord.lat, coord.lon]) : 
                            [[line.startLat, line.startLon], [line.endLat, line.endLon]];
                        
                        if (lineCoords.length > 0) {
                            const bounds = L.latLngBounds(lineCoords);
                            map.fitBounds(bounds, { padding: [20, 20] });
                            showNotification('Map zoomed to fit selected line', 'success');
                        }
                    }
                } else {
                    // Fit to all available lines
                    const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                    if (lines.length > 0) {
                        const bounds = L.latLngBounds();
                        lines.forEach(line => {
                            if (line.startLat && line.startLon && line.endLat && line.endLon) {
                                bounds.extend([line.startLat, line.startLon]);
                                bounds.extend([line.endLat, line.endLon]);
                            }
                        });
                        
                        if (!bounds.isEmpty()) {
                            map.fitBounds(bounds, { padding: [20, 20] });
                            showNotification('Map zoomed to fit all lines', 'success');
                        }
                    }
                }
            }
        }
        
        // Refresh map view
        function refreshMapView() {
            if (map) {
                if (uploadedKMLData && uploadedKMLData.lines) {
                    // Refresh KML lines
                    highlightAllKMLLines(uploadedKMLData.lines);
                } else {
                    // Refresh default view
                    updateMap();
                }
                showNotification('Map view refreshed!', 'success');
            }
        }
        
        function parseKMLFile(kmlContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(kmlContent, 'text/xml');
            
            // Check for parsing errors
            const parseError = xmlDoc.getElementsByTagName('parsererror');
            if (parseError.length > 0) {
                throw new Error('Invalid XML/KML format');
            }
            
            const lines = [];
            const placemarks = xmlDoc.getElementsByTagName('Placemark');
            
            for (let placemark of placemarks) {
                const name = getElementText(placemark, 'name') || 'Unnamed Line';
                const description = getElementText(placemark, 'description') || '';
                const coordinates = getCoordinates(placemark);
                
                if (coordinates && coordinates.length >= 2) {
                    // Determine line type based on name or description
                    const lineType = determineLineType(name, description);
                    
                    // Extract additional properties
                    const voltage = extractVoltage(name, description);
                    const region = extractRegion(name, description);
                    
                    const line = {
                        id: generateLineId(name, lines.length),
                        name: name,
                        voltage: voltage || 'Unknown',
                        region: region || 'Unknown',
                        lineType: lineType,
                        length: calculateLineLength(coordinates),
                        capacity: Math.random() * 1000 + 100,
                        load: Math.random() * 80 + 20,
                        status: 'Active',
                        startLat: coordinates[0].lat,
                        startLon: coordinates[0].lon,
                        endLat: coordinates[coordinates.length - 1].lat,
                        endLon: coordinates[coordinates.length - 1].lon,
                        coordinates: coordinates
                    };
                    
                    lines.push(line);
                }
            }
            
            return {
                lines: lines,
                lineType: determineOverallLineType(lines),
                region: determineOverallRegion(lines)
            };
        }
        
        function getElementText(element, tagName) {
            const tag = element.getElementsByTagName(tagName)[0];
            return tag ? tag.textContent.trim() : '';
        }
        
        function getCoordinates(placemark) {
            const coordinates = [];
            const coordElements = placemark.getElementsByTagName('coordinates');
            
            for (let coordElement of coordElements) {
                const coordText = coordElement.textContent.trim();
                const coordPairs = coordText.split(/\s+/);
                
                for (let pair of coordPairs) {
                    const parts = pair.split(',');
                    if (parts.length >= 2) {
                        const lon = parseFloat(parts[0]);
                        const lat = parseFloat(parts[1]);
                        
                        if (!isNaN(lat) && !isNaN(lon)) {
                            coordinates.push({ lat: lat, lon: lon });
                        }
                    }
                }
            }
            
            return coordinates;
        }
        
        function determineLineType(name, description) {
            const text = (name + ' ' + description).toLowerCase();
            
            if (text.includes('transmission') || text.includes('high voltage') || 
                text.includes('hv') || text.includes('69kv') || text.includes('115kv') || 
                text.includes('230kv') || text.includes('345kv') || text.includes('500kv') || 
                text.includes('765kv')) {
                return 'transmission';
            } else if (text.includes('distribution') || text.includes('low voltage') || 
                       text.includes('lv') || text.includes('11kv') || text.includes('22kv') || 
                       text.includes('33kv') || text.includes('66kv') || text.includes('110kv') || 
                       text.includes('132kv')) {
                return 'distribution';
            }
            
            // Default to transmission if uncertain
            return 'transmission';
        }
        
        function extractVoltage(name, description) {
            const text = (name + ' ' + description).toLowerCase();
            const voltageMatch = text.match(/(\d+)\s*kv/i);
            return voltageMatch ? voltageMatch[1] + 'kV' : 'Unknown';
        }
        
        function extractRegion(name, description) {
            const text = (name + ' ' + description).toLowerCase();
            
            const regions = [
                'northern california', 'southern california', 'central valley', 
                'sierra nevada', 'coastal region', 'bay area', 'sacramento valley',
                'san joaquin valley', 'mountain region', 'desert region'
            ];
            
            for (let region of regions) {
                if (text.includes(region)) {
                    return region.replace(/\b\w/g, l => l.toUpperCase());
                }
            }
            
            return 'Unknown';
        }
        
        function generateLineId(name, index) {
            const prefix = name.toLowerCase().includes('transmission') ? 'TL' : 'DL';
            return `${prefix}${(index + 1).toString().padStart(3, '0')}`;
        }
        
        function calculateLineLength(coordinates) {
            if (coordinates.length < 2) return 0;
            
            let totalLength = 0;
            for (let i = 1; i < coordinates.length; i++) {
                const prev = coordinates[i - 1];
                const curr = coordinates[i];
                totalLength += calculateDistance(prev.lat, prev.lon, curr.lat, curr.lon);
            }
            
            return totalLength;
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function determineOverallLineType(lines) {
            const transmissionCount = lines.filter(l => l.lineType === 'transmission').length;
            const distributionCount = lines.filter(l => l.lineType === 'distribution').length;
            return transmissionCount >= distributionCount ? 'transmission' : 'distribution';
        }
        
        function determineOverallRegion(lines) {
            const regions = {};
            lines.forEach(line => {
                if (line.region !== 'Unknown') {
                    regions[line.region] = (regions[line.region] || 0) + 1;
                }
            });
            
            const mostCommon = Object.keys(regions).sort((a, b) => regions[b] - regions[a])[0];
            return mostCommon || 'Unknown';
        }
        
        function updateLineDataFromKML(parsedData) {
            console.log('üîç updateLineDataFromKML called with:', parsedData);
            
            // Store KML data globally
            uploadedKMLData = parsedData;
            console.log('üîç Global KML data set:', uploadedKMLData);
            
            // Ensure the lines have proper structure
            if (parsedData.lines && parsedData.lines.length > 0) {
                parsedData.lines.forEach((line, index) => {
                    // Ensure each line has required properties
                    if (!line.id) line.id = `KML_${index + 1}`;
                    if (!line.name) line.name = `KML Line ${index + 1}`;
                    if (!line.voltage) line.voltage = 'Unknown';
                    if (!line.region) line.region = 'KML Import';
                    if (!line.status) line.status = 'Active';
                    if (!line.length) line.length = 1.0;
                    if (!line.capacity) line.capacity = 100;
                    if (!line.load) line.load = 50;
                });
            }
            
            if (parsedData.lineType === 'transmission') {
                transmissionLines = parsedData.lines;
                currentLineType = 'transmission';
            } else {
                distributionLines = parsedData.lines;
                currentLineType = 'distribution';
            }
            
            console.log('üîç Updated line arrays:', { transmissionLines: transmissionLines.length, distributionLines: distributionLines.length });
            console.log('üîç Sample line data:', transmissionLines[0] || distributionLines[0]);
            
            // Update UI
            document.getElementById('line-type-select').value = currentLineType;
            updateVoltageOptions();
            populateLineSelector();
            updateOverviewMetrics();
            
            // Clear current selection
            selectedLineId = null;
            document.getElementById('line-details').style.display = 'none';
            
            // Automatically zoom to KML location and highlight all lines
            setTimeout(() => {
                zoomToKMLLocation(parsedData.lines);
                highlightAllKMLLines(parsedData.lines);
            }, 500);
            
            showNotification(`Loaded ${parsedData.lines.length} ${parsedData.lineType} lines from KML file.`, 'success');
        }
        
        // Function to zoom to KML location
        function zoomToKMLLocation(lines) {
            if (!map || lines.length === 0) return;
            
            console.log('üó∫Ô∏è Zooming to KML location...');
            
            try {
                // Ensure map is properly initialized
                if (!map._loaded) {
                    console.log('Map not fully loaded, reinitializing...');
                    updateMap();
                    setTimeout(() => zoomToKMLLocation(lines), 500);
                    return;
                }
                
                // Calculate bounds for all lines
                const bounds = L.latLngBounds();
                
                lines.forEach(line => {
                    if (line.coordinates && line.coordinates.length > 0) {
                        // Add all coordinates to bounds
                        line.coordinates.forEach(coord => {
                            if (coord.lat && coord.lon && !isNaN(coord.lat) && !isNaN(coord.lon)) {
                                bounds.extend([coord.lat, coord.lon]);
                            }
                        });
                    } else if (line.startLat && line.startLon && line.endLat && line.endLon) {
                        // Add start and end points to bounds
                        if (!isNaN(line.startLat) && !isNaN(line.startLon)) {
                            bounds.extend([line.startLat, line.startLon]);
                        }
                        if (!isNaN(line.endLat) && !isNaN(line.endLon)) {
                            bounds.extend([line.endLat, line.endLon]);
                        }
                    }
                });
                
                // Fit map to bounds with padding
                if (!bounds.isEmpty()) {
                    map.fitBounds(bounds, { 
                        padding: [20, 20],
                        animate: true,
                        duration: 1.0
                    });
                    console.log('‚úÖ Map zoomed to KML location');
                    showNotification('Map zoomed to KML location', 'success');
                    
                    // Force map update
                    map.invalidateSize();
                } else {
                    console.warn('No valid coordinates found for zooming');
                    showNotification('No valid coordinates found for zooming', 'warning');
                }
            } catch (error) {
                console.error('Error zooming to KML location:', error);
                showNotification('Error zooming to KML location. Please try again.', 'error');
            }
        }
        
        // Helper function to check if map is properly initialized
        function isMapValid() {
            if (!map) {
                console.warn('Map variable is null or undefined');
                return false;
            }
            
            if (typeof map.eachLayer !== 'function') {
                console.warn('Map object does not have eachLayer method - not a valid Leaflet map');
                return false;
            }
            
            if (typeof map.setView !== 'function') {
                console.warn('Map object does not have setView method - not a valid Leaflet map');
                return false;
            }
            
            return true;
        }
        
        // Helper function to safely clear map layers
        function clearMapLayers() {
            if (!isMapValid()) {
                console.warn('Map not properly initialized, cannot clear layers');
                return;
            }
            
            try {
                map.eachLayer((layer) => {
                    if (!(layer instanceof L.TileLayer)) {
                        map.removeLayer(layer);
                    }
                });
            } catch (error) {
                console.warn('Error clearing map layers:', error);
            }
        }
        
        // Function to highlight all KML lines with red color
        function highlightAllKMLLines(lines) {
            if (!map || lines.length === 0) return;
            
            console.log('üî¥ Highlighting all KML lines...');
            
            // Clear existing layers first
            clearMapLayers();
            
            // Add tile layer back
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            lines.forEach((line, index) => {
                // Use detailed coordinates if available (from KML), otherwise use start/end points
                let lineCoords;
                if (line.coordinates && line.coordinates.length > 0) {
                    lineCoords = line.coordinates.map(coord => [coord.lat, coord.lon]);
                } else {
                    lineCoords = [[line.startLat, line.startLon], [line.endLat, line.endLon]];
                }
                
                // Validate coordinates before creating the line
                if (!lineCoords || lineCoords.length < 2) {
                    console.warn(`Skipping line ${index}: insufficient coordinates`);
                    return;
                }
                
                // Create red highlighted line
                const powerLine = L.polyline(lineCoords, {
                    color: '#e74c3c', // Red color for KML lines
                    weight: 8,
                    opacity: 0.9,
                    dashArray: '5, 5' // Dashed line to make it stand out
                }).addTo(map);
                
                // Add popup to the line with safe property access
                const lineName = line.name || `KML Line ${index + 1}`;
                const lineId = line.id || `kml_${index}`;
                const lineVoltage = line.voltage || 'Unknown';
                const lineType = line.type || 'KML Import';
                const lineRegion = line.region || 'Unknown';
                const lineLength = line.length ? `${line.length.toFixed(1)} km` : 'Unknown';
                const lineStatus = line.status || 'Active';
                
                powerLine.bindPopup(`
                    <div style="min-width: 200px;">
                        <h4 style="margin: 0 0 10px 0; color: #e74c3c;">${lineName}</h4>
                        <p><strong>ID:</strong> ${lineId}</p>
                        <p><strong>Voltage:</strong> ${lineVoltage}</p>
                        <p><strong>Type:</strong> ${lineType}</p>
                        <p><strong>Region:</strong> ${lineRegion}</p>
                        <p><strong>Length:</strong> ${lineLength}</p>
                        <p><strong>Status:</strong> ${lineStatus}</p>
                        <p style="margin-top: 10px; font-size: 12px; color: #e74c3c;">
                            üìç KML Imported Line
                        </p>
                    </div>
                `);
                
                // Add start and end markers
                if (lineCoords.length > 0) {
                    // Start marker
                    L.marker(lineCoords[0], {
                        icon: L.divIcon({
                            className: 'custom-div-icon',
                            html: `<div style="background-color: #e74c3c; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>`,
                            iconSize: [12, 12],
                            iconAnchor: [6, 6]
                        })
                    }).addTo(map).bindPopup(`<strong>Start:</strong> ${lineName}`);
                    
                    // End marker
                    L.marker(lineCoords[lineCoords.length - 1], {
                        icon: L.divIcon({
                            className: 'custom-div-icon',
                            html: `<div style="background-color: #e74c3c; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>`,
                            iconSize: [12, 12],
                            iconAnchor: [6, 6]
                        })
                    }).addTo(map).bindPopup(`<strong>End:</strong> ${lineName}`);
                }
            });
            
            console.log(`‚úÖ Highlighted ${lines.length} KML lines with red color`);
        }
        
        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üå≥ Vegetation Management Agent - Loading...');
            console.log('üîß API Base URL:', apiBaseUrl);
            
            // Check API connection first
            await checkApiConnection();
            
            loadTransmissionData();
            loadDistributionData();
            updateVoltageOptions(); // Set initial voltage options
            initializeCharts();
            
            // Initialize map after a short delay to ensure DOM is ready
            setTimeout(() => {
                console.log('Initializing map on page load');
                updateMap();
            }, 1000);
            
            if (isApiConnected) {
                showNotification('üöÄ Connected to Python AI backend!', 'success');
            } else {
                showNotification('‚ö†Ô∏è Using local analysis (Python backend unavailable)', 'warning');
            }
            
            // Add manual API test function to window for debugging
            window.testApiConnection = async function() {
                console.log('üß™ Manual API connection test...');
                const result = await checkApiConnection();
                console.log('API connection result:', result);
                return result;
            };
            
                    // Add force refresh function
        window.forceRefresh = function() {
            console.log('üîÑ Force refreshing page...');
            window.location.reload(true);
        };
        
        // Add API status check
        window.checkApiStatus = function() {
            console.log('üìä API Status Check:');
            console.log('- isApiConnected:', isApiConnected);
            console.log('- isApiConnected:', isApiConnected);
            console.log('- apiBaseUrl:', apiBaseUrl);
            console.log('- API Status Element:', document.getElementById('api-status'));
        };
        
        // Add map zoom utility functions
        window.manualZoomIn = function() {
            if (map) {
                map.zoomIn();
                showNotification('Map zoomed in', 'info');
            }
        };
        
        window.manualZoomOut = function() {
            if (map) {
                map.zoomOut();
                showNotification('Map zoomed out', 'info');
            }
        };
        
        window.manualResetView = function() {
            resetMapView();
        };
        
        window.manualZoomToFit = function() {
            zoomToFit();
        };
        
        // Debug KML data
        window.debugKMLData = function() {
            console.log('üîç Debug KML Data:');
            console.log('- uploadedKMLData:', uploadedKMLData);
            console.log('- map:', map);
            console.log('- Leaflet available:', typeof L !== 'undefined');
            
            if (uploadedKMLData && uploadedKMLData.lines) {
                console.log('- Lines count:', uploadedKMLData.lines.length);
                console.log('- Sample line:', uploadedKMLData.lines[0]);
                
                // Test map config creation
                console.log('üß™ Testing map config creation...');
                const testConfig = createMapConfigFromLines(uploadedKMLData.lines);
                console.log('- Test config result:', testConfig);
                
                // Test simple config creation
                console.log('üß™ Testing simple config creation...');
                const simpleConfig = createSimpleMapConfig(uploadedKMLData.lines);
                console.log('- Simple config result:', simpleConfig);
            }
            
            // Test map state
            if (map) {
                console.log('- Map loaded:', map._loaded);
                console.log('- Map center:', map.getCenter());
                console.log('- Map zoom:', map.getZoom());
                console.log('- Map size:', map.getSize());
            }
            
            // Test map validation
            console.log('üß™ Testing map validation...');
            const isValid = isMapValid();
            console.log('- Map valid:', isValid);
        };
        
        // Force KML zoom
        window.forceKMLZoom = function() {
            if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                console.log('üß™ Force KML zoom...');
                applyMapZoom('forced');
            } else {
                console.log('‚ùå No KML data available for forced zoom');
            }
        };
        
        // Test map zoom with specific coordinates
        window.testMapZoom = function(lat = 37.7749, lon = -122.4194, zoom = 10) {
            console.log('üß™ Testing map zoom with coordinates:', lat, lon, zoom);
            if (map) {
                try {
                    map.setView([lat, lon], zoom, { animate: true, duration: 1.0 });
                    console.log('‚úÖ Test map zoom successful');
                    showNotification('Test map zoom successful', 'success');
                } catch (error) {
                    console.error('‚ùå Test map zoom failed:', error);
                    showNotification(`Test map zoom failed: ${error.message}`, 'error');
                }
            } else {
                console.log('‚ùå Map not available');
            }
        };
        
        // Force map reinitialization
        window.forceMapReinit = function() {
            console.log('üß™ Force map reinitialization...');
            try {
                // Clear existing map
                if (map && typeof map.remove === 'function') {
                    map.remove();
                }
                map = null;
                
                // Reinitialize map
                setTimeout(() => {
                    updateMap();
                    console.log('‚úÖ Map reinitialized');
                    showNotification('Map reinitialized', 'success');
                }, 100);
            } catch (error) {
                console.error('‚ùå Map reinitialization failed:', error);
                showNotification(`Map reinitialization failed: ${error.message}`, 'error');
            }
        };
        });

        // Load transmission line data
        function loadTransmissionData() {
            // Simulate loading transmission data
            transmissionLines = generateTransmissionData();
            updateOverviewMetrics();
        }
        
        // Load distribution line data
        function loadDistributionData() {
            // Simulate loading distribution data
            distributionLines = generateDistributionData();
        }

        // Generate mock transmission data
        function generateTransmissionData() {
            const lines = [];
            const voltageLevels = ['69kV', '115kV', '230kV', '345kV', '500kV', '765kV'];
            const regions = ['Northern California', 'Southern California', 'Central Valley', 'Sierra Nevada', 'Coastal Region'];
            
            // Define base coordinates for different regions
            const baseCoords = [
                { lat: 37.7749, lon: -122.4194, name: 'San Francisco' },
                { lat: 37.8716, lon: -122.2727, name: 'Berkeley' },
                { lat: 37.8044, lon: -122.2711, name: 'Oakland' },
                { lat: 37.9735, lon: -122.5311, name: 'Marin' },
                { lat: 37.4419, lon: -122.1430, name: 'Palo Alto' }
            ];
            
            for (let i = 1; i <= 100; i++) {
                const baseCoord = baseCoords[i % baseCoords.length];
                const angle = (i * 137.5) % 360; // Golden angle for better distribution
                const distance = 0.1 + (Math.random() * 0.3); // 0.1 to 0.4 degrees
                
                // Calculate start and end points
                const startLat = baseCoord.lat + Math.cos(angle * Math.PI / 180) * distance;
                const startLon = baseCoord.lon + Math.sin(angle * Math.PI / 180) * distance;
                const endLat = startLat + (Math.random() - 0.5) * 0.2;
                const endLon = startLon + (Math.random() - 0.5) * 0.2;
                
                lines.push({
                    id: `TL${i.toString().padStart(3, '0')}`,
                    name: `Transmission Line ${i}`,
                    voltage: voltageLevels[Math.floor(Math.random() * voltageLevels.length)],
                    region: regions[Math.floor(Math.random() * regions.length)],
                    length: Math.random() * 50 + 10,
                    capacity: Math.random() * 1000 + 100,
                    load: Math.random() * 80 + 20,
                    status: 'Active',
                    startLat: startLat,
                    startLon: startLon,
                    endLat: endLat,
                    endLon: endLon
                });
            }
            return lines;
        }
        
        // Generate mock distribution data
        function generateDistributionData() {
            const lines = [];
            const voltageLevels = ['11kV', '22kV', '33kV', '66kV', '110kV', '132kV'];
            const regions = ['Northern California', 'Southern California', 'Central Valley', 'Bay Area', 'Sacramento Valley', 'San Joaquin Valley', 'Coastal Region', 'Mountain Region', 'Desert Region'];
            const lineTypes = ['Overhead', 'Underground', 'Mixed'];
            const statuses = ['Active', 'Maintenance', 'Planned'];
            
            // Define base coordinates for different regions (slightly different from transmission)
            const baseCoords = [
                { lat: 37.7849, lon: -122.4094, name: 'San Francisco Downtown' },
                { lat: 37.8616, lon: -122.2627, name: 'Berkeley North' },
                { lat: 37.8144, lon: -122.2611, name: 'Oakland Central' },
                { lat: 37.9635, lon: -122.5211, name: 'Marin South' },
                { lat: 37.4519, lon: -122.1330, name: 'Palo Alto North' }
            ];
            
            for (let i = 1; i <= 100; i++) {
                const baseCoord = baseCoords[i % baseCoords.length];
                const angle = (i * 137.5 + 45) % 360; // Golden angle + offset for distribution
                const distance = 0.05 + (Math.random() * 0.15); // Shorter distances for distribution lines
                
                // Calculate start and end points
                const startLat = baseCoord.lat + Math.cos(angle * Math.PI / 180) * distance;
                const startLon = baseCoord.lon + Math.sin(angle * Math.PI / 180) * distance;
                const endLat = startLat + (Math.random() - 0.5) * 0.1;
                const endLon = startLon + (Math.random() - 0.5) * 0.1;
                
                lines.push({
                    id: `DL${i.toString().padStart(3, '0')}`,
                    name: `Distribution Line ${i}`,
                    voltage: voltageLevels[Math.floor(Math.random() * voltageLevels.length)],
                    region: regions[Math.floor(Math.random() * regions.length)],
                    lineType: lineTypes[Math.floor(Math.random() * lineTypes.length)],
                    status: statuses[Math.floor(Math.random() * statuses.length)],
                    length: Math.random() * 20 + 2,
                    capacity: Math.random() * 50 + 5,
                    load: Math.random() * 80 + 20,
                    customerCount: Math.floor(Math.random() * 5000) + 50,
                    peakDemand: Math.random() * 100 + 10,
                    reliabilityScore: Math.random() * 0.14 + 0.85,
                    startLat: startLat,
                    startLon: startLon,
                    endLat: endLat,
                    endLon: endLon
                });
            }
            return lines;
        }

        // Switch line type
        function switchLineType() {
            const lineTypeSelect = document.getElementById('line-type-select');
            currentLineType = lineTypeSelect.value;
            
            // Update voltage filter options based on line type
            updateVoltageOptions();
            
            // Clear current selection
            selectedLineId = null;
            document.getElementById('line-details').style.display = 'none';
            
            // Repopulate line selector
            populateLineSelector();
            
            // Update overview metrics for new line type
            updateOverviewMetrics();
            
            // Show notification
            const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
            showNotification(`Switched to ${lineTypeText} lines`, 'info');
        }
        
        // Update voltage options based on line type
        function updateVoltageOptions() {
            const voltageSelect = document.getElementById('voltage-filter');
            const transmissionVoltages = ['69kV', '115kV', '230kV', '345kV', '500kV', '765kV'];
            const distributionVoltages = ['11kV', '22kV', '33kV', '66kV', '110kV', '132kV'];
            
            // Clear existing options
            voltageSelect.innerHTML = '<option value="">üåê All Voltage Levels</option>';
            
            // Add appropriate voltage options
            const voltages = currentLineType === 'transmission' ? transmissionVoltages : distributionVoltages;
            const icon = currentLineType === 'transmission' ? '‚ö°' : 'üîå';
            
            voltages.forEach(voltage => {
                const option = document.createElement('option');
                option.value = voltage;
                option.textContent = `${icon} ${voltage}`;
                voltageSelect.appendChild(option);
            });
        }
        
        // Populate line selector
        function populateLineSelector() {
            const select = document.getElementById('line-select');
            select.innerHTML = '<option value="">Select Power Line</option>';
            
            // Get the current lines (either from KML or default data)
            let lines;
            if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                // Use KML data if available
                lines = uploadedKMLData.lines;
                console.log('üîç Populating line selector with KML data:', lines.length, 'lines');
            } else {
                // Use default transmission/distribution lines
                lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                console.log('üîç Populating line selector with default data:', lines.length, 'lines');
            }
            
            lines.forEach(line => {
                const option = document.createElement('option');
                option.value = line.id;
                option.textContent = `${line.id} - ${line.name} (${line.voltage})`;
                select.appendChild(option);
            });
            
            console.log('‚úÖ Line selector populated with', lines.length, 'lines');
        }
        
        // Populate transmission selector (legacy)
        function populateTransmissionSelector() {
            populateLineSelector();
        }

        // Filter lines
        function filterLines() {
            const voltageFilter = document.getElementById('voltage-filter').value;
            const regionFilter = document.getElementById('region-filter').value;
            
            const select = document.getElementById('line-select');
            select.innerHTML = '<option value="">Select Power Line</option>';
            
            // Get the current lines (either from KML or default data)
            let lines;
            if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                // Use KML data if available
                lines = uploadedKMLData.lines;
                console.log('üîç Filtering KML data:', lines.length, 'lines');
            } else {
                // Use default transmission/distribution lines
                lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                console.log('üîç Filtering default data:', lines.length, 'lines');
            }
            
            lines.forEach(line => {
                if ((!voltageFilter || line.voltage === voltageFilter) &&
                    (!regionFilter || line.region === regionFilter)) {
                    const option = document.createElement('option');
                    option.value = line.id;
                    option.textContent = `${line.id} - ${line.name} (${line.voltage})`;
                    select.appendChild(option);
                }
            });
        }

        // Select line
        function selectLine() {
            const select = document.getElementById('line-select');
            const newSelectedLineId = select.value;
            
            // Clear previous vegetation data when switching lines
            if (selectedLineId && selectedLineId !== newSelectedLineId) {
                console.log('üîÑ Clearing previous vegetation data for line:', selectedLineId);
                vegetationData = [];
                riskAssessmentData = null;
                growthPredictionData = null;
                
                // Clear all analysis sections immediately
                clearAllAnalysisSections();
                
                // Show notification about clearing data
                showNotification('Previous analysis data cleared. Click "Report Generator" to analyze the new line.', 'info');
            }
            
            selectedLineId = newSelectedLineId;
            
            if (selectedLineId) {
                // Get the current lines (either from KML or default data)
                let lines;
                if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                    // Use KML data if available
                    lines = uploadedKMLData.lines;
                    console.log('üîç Using KML data for line selection');
                } else {
                    // Use default transmission/distribution lines
                    lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                    console.log('üîç Using default data for line selection');
                }
                
                const line = lines.find(l => l.id === selectedLineId);
                
                if (line) {
                displayLineDetails(line);
                    
                    // Update map with new line
                setTimeout(() => {
                updateMap();
                }, 100);
                    
                // Update overview metrics for selected line
                updateOverviewMetrics();
                    
                    // Show message that user needs to generate report
                    showLineSelectedMessage(line);
                } else {
                    console.error('‚ùå Line not found:', selectedLineId);
                    showNotification('Selected line not found. Please try selecting another line.', 'error');
                    selectedLineId = null;
                    document.getElementById('line-details').style.display = 'none';
                }
            } else {
                document.getElementById('line-details').style.display = 'none';
                // Clear vegetation data when no line is selected
                vegetationData = [];
                clearAllAnalysisSections();
                // Update overview metrics when no line is selected
                updateOverviewMetrics();
            }
        }
        
        // Function to clear all analysis sections
        function clearAllAnalysisSections() {
            // Clear vegetation analysis
            const vegetationContent = document.getElementById('vegetation-analysis-content');
            if (vegetationContent) {
                vegetationContent.innerHTML = `
                    <div class="no-data-message">
                        <p>üìä <strong>No Analysis Data Available</strong></p>
                        <p>Please select a line and click "Report Generator" to analyze vegetation.</p>
                    </div>
                `;
            }
            
            // Clear risk assessment
            const riskContent = document.getElementById('risk-assessment-content');
            if (riskContent) {
                riskContent.innerHTML = `
                    <div class="no-data-message">
                        <p>‚ö†Ô∏è <strong>No Risk Assessment Available</strong></p>
                        <p>Please select a line and click "Report Generator" to analyze risk.</p>
                    </div>
                `;
            }
            
            // Clear high-risk vegetation
            const highRiskContent = document.getElementById('high-risk-vegetation');
            if (highRiskContent) {
                highRiskContent.innerHTML = `
                    <div class="no-data-message">
                        <p>üö® <strong>No High-Risk Data Available</strong></p>
                        <p>Please select a line and click "Report Generator" to identify high-risk vegetation.</p>
                    </div>
                `;
            }
            
            // Clear growth prediction
            const growthContent = document.getElementById('growth-prediction-content');
            if (growthContent) {
                growthContent.innerHTML = `
                    <div class="no-data-message">
                        <p>üìà <strong>No Growth Prediction Available</strong></p>
                        <p>Please select a line and click "Report Generator" to analyze growth.</p>
                    </div>
                `;
            }
            
            // Clear maintenance schedule
            const scheduleContent = document.getElementById('maintenance-schedule-content');
            if (scheduleContent) {
                scheduleContent.innerHTML = `
                    <div class="no-data-message">
                        <p>üìÖ <strong>No Maintenance Schedule Available</strong></p>
                        <p>Please select a line and click "Report Generator" to generate maintenance schedule.</p>
                    </div>
                `;
            }
        }
        
        // Function to show line selected message
        function showLineSelectedMessage(line) {
            const vegetationContent = document.getElementById('vegetation-analysis-content');
            if (vegetationContent) {
                vegetationContent.innerHTML = `
                    <div class="no-data-message">
                        <p>üìä <strong>Line Selected: ${line.name}</strong></p>
                        <p>Click "Report Generator" to analyze vegetation for this line.</p>
                        <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                            Previous analysis data has been cleared. Generate a new report for this specific line.
                        </p>
                    </div>
                `;
            }
        }
        
        // Legacy functions for backward compatibility
        function filterTransmissionLines() {
            filterLines();
        }
        
        function selectTransmissionLine() {
            selectLine();
        }

        // Display line details
        function displayLineDetails(line) {
            const detailsDiv = document.getElementById('line-details');
            const infoDiv = document.getElementById('line-info');
            const badgeDiv = document.getElementById('line-type-badge');
            
            // Update line type badge
            badgeDiv.textContent = currentLineType === 'transmission' ? '‚ö° Transmission' : 'üîå Distribution';
            badgeDiv.className = `line-type-badge ${currentLineType}`;
            
            let detailsHTML = `
                <p><strong>Name:</strong> ${line.name}</p>
                <p><strong>Voltage:</strong> ${line.voltage}</p>
                <p><strong>Region:</strong> ${line.region}</p>
                <p><strong>Length:</strong> ${line.length.toFixed(1)} km</p>
                <p><strong>Capacity:</strong> ${line.capacity.toFixed(0)} MW</p>
                <p><strong>Load:</strong> ${line.load.toFixed(1)}%</p>
                <p><strong>Status:</strong> ${line.status}</p>
            `;
            
            // Add distribution-specific details
            if (currentLineType === 'distribution') {
                detailsHTML += `
                    <p><strong>Type:</strong> ${line.lineType}</p>
                    <p><strong>Customers:</strong> ${line.customerCount.toLocaleString()}</p>
                    <p><strong>Peak Demand:</strong> ${line.peakDemand.toFixed(1)} MW</p>
                    <p><strong>Reliability:</strong> ${(line.reliabilityScore * 100).toFixed(1)}%</p>
                `;
            }
            
            infoDiv.innerHTML = detailsHTML;
            detailsDiv.style.display = 'block';
        }

        // Load vegetation data
        async function loadVegetationData(lineId) {
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const lineData = lines.find(l => l.id === lineId);
            
            if (!lineData) {
                showNotification('Line data not found', 'error');
                return;
            }
            
            // Show loading state
            showNotification('üîç Analyzing vegetation data...', 'info');
            
            try {
                // Try to get data from Python API first
                const apiData = await getVegetationAnalysis(lineId, lineData);
                
                if (apiData && apiData.length > 0) {
                    vegetationData = apiData;
                    showNotification(`‚úÖ Found ${vegetationData.length} vegetation points`, 'success');
                } else {
                    // No data from API, try fallback
                    console.log('No API data, trying fallback generation...');
                    vegetationData = generateVegetationData(lineId);
                    
                    if (vegetationData && vegetationData.length > 0) {
                        showNotification(`‚úÖ Generated ${vegetationData.length} vegetation points (fallback)`, 'success');
                } else {
                    showNotification('üèôÔ∏è No vegetation risk detected in this area', 'info');
                    }
                }
                
                // Update all sections
                updateVegetationAnalysis();
                updateRiskAssessment();
                updateGrowthPrediction();
                updateMap();
                updateOverviewMetrics();
                
            } catch (error) {
                console.error('Error loading vegetation data:', error);
                showNotification('‚ö†Ô∏è Using fallback analysis (API unavailable)', 'warning');
                
                // Fallback to local generation
                try {
                vegetationData = generateVegetationData(lineId);
                    
                    if (vegetationData && vegetationData.length > 0) {
                        showNotification(`‚úÖ Generated ${vegetationData.length} vegetation points (fallback)`, 'success');
                    } else {
                        showNotification('üèôÔ∏è No vegetation risk detected in this area', 'info');
                    }
                    
                updateVegetationAnalysis();
                updateRiskAssessment();
                updateGrowthPrediction();
                updateMap();
                updateOverviewMetrics();
                    
                } catch (fallbackError) {
                    console.error('Fallback generation failed:', fallbackError);
                    showNotification('Error generating vegetation data. Please try again.', 'error');
                    vegetationData = [];
                }
            }
        }

        // Generate intelligent vegetation data based on geographical context
        function generateVegetationData(lineId) {
            const vegetation = [];
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const line = lines.find(l => l.id === lineId);
            
            if (!line) {
                return [];
            }
            
            // Analyze geographical context to determine if vegetation is likely
            const context = analyzeGeographicalContext(line);
            
            if (!context.hasVegetation) {
                // No vegetation risk in this area
                return [];
            }
            
            // Determine vegetation types based on region and context
            const vegetationTypes = getVegetationTypesForRegion(line.region, context);
            const vegetationCount = Math.floor(Math.random() * context.maxVegetationCount) + context.minVegetationCount;
            
            for (let i = 1; i <= vegetationCount; i++) {
                const height = Math.random() * context.maxHeight + context.minHeight;
                const distance = Math.random() * context.maxDistance; // 0 to max distance
                
                // Intelligent distance-based risk logic
                let riskLevel, riskScore, priority;
                
                if (distance < 10) {
                    riskLevel = 'Critical';
                    riskScore = 0.9 + (Math.random() * 0.1);
                    priority = 'Immediate';
                } else if (distance < 20) {
                    riskLevel = 'High';
                    riskScore = 0.7 + (Math.random() * 0.2);
                    priority = 'High';
                } else if (distance < 30) {
                    riskLevel = 'Medium';
                    riskScore = 0.4 + (Math.random() * 0.3);
                    priority = 'Medium';
                } else if (distance < 50) {
                    riskLevel = 'Low';
                    riskScore = 0.1 + (Math.random() * 0.3);
                    priority = 'Low';
                } else {
                    riskLevel = 'Very Low';
                    riskScore = Math.random() * 0.1;
                    priority = 'Monitor';
                }
                
                vegetation.push({
                    id: `VEG${lineId}_${i.toString().padStart(2, '0')}`,
                    type: vegetationTypes[Math.floor(Math.random() * vegetationTypes.length)],
                    height: height,
                    distance: distance,
                    riskScore: riskScore,
                    riskLevel: riskLevel,
                    growthRate: Math.random() * 0.5 + 0.1,
                    health: Math.random() > 0.2 ? 'Healthy' : 'Stressed',
                    priority: priority,
                    estimatedCost: riskLevel === 'Critical' ? Math.random() * 10000 + 5000 :
                                 riskLevel === 'High' ? Math.random() * 5000 + 2000 :
                                 riskLevel === 'Medium' ? Math.random() * 3000 + 1000 :
                                 riskLevel === 'Low' ? Math.random() * 2000 + 500 :
                                 Math.random() * 1000 + 200
                });
            }
            return vegetation;
        }
        
        // Analyze geographical context to determine vegetation likelihood
        function analyzeGeographicalContext(line) {
            const context = {
                hasVegetation: true,
                maxVegetationCount: 15,
                minVegetationCount: 5,
                maxHeight: 25,
                minHeight: 3,
                maxDistance: 50
            };
            
            // Check if line is in urban/road area
            if (isUrbanArea(line)) {
                context.hasVegetation = false;
                return context;
            }
            
            // Check if line is in rural/forest area
            if (isRuralArea(line)) {
                context.maxVegetationCount = 25;
                context.minVegetationCount = 10;
                context.maxHeight = 35;
                context.maxDistance = 80;
            }
            
            // Check if line is in suburban area
            if (isSuburbanArea(line)) {
                context.maxVegetationCount = 15;
                context.minVegetationCount = 5;
                context.maxHeight = 20;
                context.maxDistance = 40;
            }
            
            return context;
        }
        
        // Check if line is in urban/road area
        function isUrbanArea(line) {
            const urbanKeywords = ['road', 'street', 'avenue', 'boulevard', 'highway', 'freeway', 'urban', 'city', 'downtown'];
            const lineText = (line.name + ' ' + (line.region || '')).toLowerCase();
            
            // Check for urban keywords
            for (let keyword of urbanKeywords) {
                if (lineText.includes(keyword)) {
                    return true;
                }
            }
            
            // Check if line is in known urban coordinates
            const urbanAreas = [
                { lat: 37.7749, lon: -122.4194, radius: 0.1 }, // San Francisco
                { lat: 37.8716, lon: -122.2727, radius: 0.1 }, // Berkeley
                { lat: 37.8044, lon: -122.2711, radius: 0.1 }  // Oakland
            ];
            
            for (let area of urbanAreas) {
                if (isWithinRadius(line.startLat, line.startLon, area.lat, area.lon, area.radius)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if line is in rural/forest area
        function isRuralArea(line) {
            const ruralKeywords = ['forest', 'rural', 'mountain', 'wilderness', 'park', 'reserve'];
            const lineText = (line.name + ' ' + (line.region || '')).toLowerCase();
            
            for (let keyword of ruralKeywords) {
                if (lineText.includes(keyword)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if line is in suburban area
        function isSuburbanArea(line) {
            const suburbanKeywords = ['suburban', 'residential', 'neighborhood', 'community'];
            const lineText = (line.name + ' ' + (line.region || '')).toLowerCase();
            
            for (let keyword of suburbanKeywords) {
                if (lineText.includes(keyword)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if coordinates are within a radius
        function isWithinRadius(lat1, lon1, lat2, lon2, radius) {
            const distance = calculateDistance(lat1, lon1, lat2, lon2);
            return distance <= radius;
        }
        
        // Get vegetation types based on region
        function getVegetationTypesForRegion(region, context) {
            const regionLower = (region || '').toLowerCase();
            
            if (regionLower.includes('forest') || regionLower.includes('mountain')) {
                return ['Pine', 'Redwood', 'Cedar', 'Fir', 'Oak'];
            } else if (regionLower.includes('coastal')) {
                return ['Eucalyptus', 'Cypress', 'Monterey Pine', 'Coastal Oak'];
            } else if (regionLower.includes('valley')) {
                return ['Oak', 'Maple', 'Cottonwood', 'Willow'];
            } else {
                return ['Oak', 'Pine', 'Eucalyptus', 'Maple', 'Cypress'];
            }
        }

        // Update vegetation analysis
        function updateVegetationAnalysis() {
            const content = document.getElementById('vegetation-analysis-content');
            
            if (vegetationData.length === 0) {
                // Check if this is due to urban/road area
                const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                const selectedLine = lines.find(l => l.id === selectedLineId);
                
                if (selectedLine) {
                    const context = analyzeGeographicalContext(selectedLine);
                    if (!context.hasVegetation) {
                        content.innerHTML = `
                            <div class="no-data-message">
                                <p>üèôÔ∏è <strong>Urban/Road Area Detected</strong></p>
                                <p>No vegetation risk analysis needed for this location.</p>
                                <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                    This line appears to be in an urban or road area where vegetation 
                                    interference is unlikely. The system has automatically determined 
                                    that no vegetation management is required.
                                </p>
                            </div>
                        `;
                    } else {
                        // Don't override the line selected message if it exists
                        const currentContent = content.innerHTML;
                        if (!currentContent.includes('Line Selected:')) {
                            content.innerHTML = `
                                <div class="no-data-message">
                                    <p>üìä <strong>No Analysis Data Available</strong></p>
                                    <p>Click "Report Generator" to analyze vegetation for ${selectedLine.name}.</p>
                                    <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                        This will generate a comprehensive vegetation analysis report for the selected line.
                                    </p>
                                </div>
                            `;
                        }
                    }
                } else {
                    content.innerHTML = `
                        <div class="no-data-message">
                            <p>üìä <strong>No Line Selected</strong></p>
                            <p>Please select a power line first, then click "Report Generator" to analyze vegetation.</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Get the selected line for the report header
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const selectedLine = lines.find(l => l.id === selectedLineId);
            const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
            
            // Calculate statistics
            const avgHeight = vegetationData.reduce((sum, v) => sum + v.height, 0) / vegetationData.length;
            const avgDistance = vegetationData.reduce((sum, v) => sum + v.distance, 0) / vegetationData.length;
            const avgGrowthRate = vegetationData.reduce((sum, v) => sum + v.growthRate, 0) / vegetationData.length;
            
            // Create the analysis content with line-specific header
            const analysisContent = `
                <div style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #007bff;">
                    <h4 style="margin: 0; color: #007bff;">üìä Analysis Report for: ${selectedLine ? selectedLine.name : 'Selected Line'}</h4>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #6c757d;">
                        Line ID: ${selectedLineId} | Type: ${lineTypeText} | Voltage: ${selectedLine ? selectedLine.voltage : 'N/A'}
                    </p>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${vegetationData.length}</div>
                        <div class="metric-label">Total Vegetation Points</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${avgHeight.toFixed(1)} m</div>
                        <div class="metric-label">Average Height</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${avgDistance.toFixed(1)} m</div>
                        <div class="metric-label">Average Distance</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${avgGrowthRate.toFixed(2)}</div>
                        <div class="metric-label">Average Growth Rate</div>
                    </div>
                </div>
            `;
            
            content.innerHTML = analysisContent;
            
            updateVegetationTable();
        }

        // Update vegetation table
        function updateVegetationTable() {
            const tbody = document.getElementById('vegetation-table-body');
            tbody.innerHTML = '';
            
            vegetationData.forEach(veg => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${veg.id}</td>
                    <td>${veg.type}</td>
                    <td>${veg.height.toFixed(1)}</td>
                    <td>${veg.distance.toFixed(1)}</td>
                    <td><span class="risk-level risk-${veg.riskLevel.toLowerCase()}">${veg.riskLevel}</span></td>
                    <td>${veg.growthRate.toFixed(2)}</td>
                    <td>${veg.health}</td>
                    <td>${veg.priority}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // Update risk assessment
        function updateRiskAssessment() {
            const content = document.getElementById('risk-assessment-content');
            const highRiskContent = document.getElementById('high-risk-vegetation');
            
            if (vegetationData.length === 0) {
                // Check if this is due to urban/road area
                const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                const selectedLine = lines.find(l => l.id === selectedLineId);
                
                if (selectedLine) {
                    const context = analyzeGeographicalContext(selectedLine);
                    if (!context.hasVegetation) {
                        content.innerHTML = `
                            <div class="no-data-message">
                                <p>üèôÔ∏è <strong>No Vegetation Risk</strong></p>
                                <p>This line is in an urban/road area with no vegetation interference.</p>
                                <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                    Line: ${selectedLine.name} | Type: ${currentLineType === 'transmission' ? 'Transmission' : 'Distribution'}
                                </p>
                            </div>
                        `;
                        highRiskContent.innerHTML = `
                            <div class="no-data-message">
                                <p>‚úÖ <strong>Low Risk Area</strong></p>
                                <p>No high-risk vegetation detected in this location.</p>
                                <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                    Line: ${selectedLine.name} | Type: ${currentLineType === 'transmission' ? 'Transmission' : 'Distribution'}
                                </p>
                            </div>
                        `;
                    } else {
                        // Don't override the clear message if it exists
                        const currentContent = content.innerHTML;
                        if (!currentContent.includes('No Risk Assessment Available')) {
                            content.innerHTML = `
                                <div class="no-data-message">
                                    <p>‚ö†Ô∏è <strong>No Risk Assessment Available</strong></p>
                                    <p>Click "Report Generator" to analyze risk for ${selectedLine.name}.</p>
                                    <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                        This will generate a comprehensive risk assessment for the selected line.
                                    </p>
                                </div>
                            `;
                        }
                        const currentHighRiskContent = highRiskContent.innerHTML;
                        if (!currentHighRiskContent.includes('No High-Risk Data Available')) {
                            highRiskContent.innerHTML = `
                                <div class="no-data-message">
                                    <p>üö® <strong>No High-Risk Data Available</strong></p>
                                    <p>Click "Report Generator" to identify high-risk vegetation for ${selectedLine.name}.</p>
                                    <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                        This will analyze and identify critical vegetation risks.
                                    </p>
                                </div>
                            `;
                        }
                    }
                                    } else {
                    content.innerHTML = `
                        <div class="no-data-message">
                            <p>‚ö†Ô∏è <strong>No Line Selected</strong></p>
                            <p>Please select a power line first, then click "Report Generator" to analyze risk.</p>
                        </div>
                    `;
                    highRiskContent.innerHTML = `
                        <div class="no-data-message">
                            <p>üö® <strong>No Line Selected</strong></p>
                            <p>Please select a power line first, then click "Report Generator" to identify high-risk vegetation.</p>
                        </div>
                    `;
                    }
                return;
            }
            
            // Get the selected line for the report header
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const selectedLine = lines.find(l => l.id === selectedLineId);
            const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
            
            // Calculate risk statistics
            const criticalRisks = vegetationData.filter(v => v.riskLevel === 'Critical').length;
            const highRisks = vegetationData.filter(v => v.riskLevel === 'High').length;
            const mediumRisks = vegetationData.filter(v => v.riskLevel === 'Medium').length;
            const lowRisks = vegetationData.filter(v => v.riskLevel === 'Low').length;
            const veryLowRisks = vegetationData.filter(v => v.riskLevel === 'Very Low').length;
            
            const avgRiskScore = vegetationData.reduce((sum, v) => sum + v.riskScore, 0) / vegetationData.length;
            
            // Create risk assessment content with line-specific header
            const riskContent = `
                <div style="background: #fff3cd; padding: 10px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #ffc107;">
                    <h4 style="margin: 0; color: #856404;">‚ö†Ô∏è Risk Assessment for: ${selectedLine ? selectedLine.name : 'Selected Line'}</h4>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #856404;">
                        Line ID: ${selectedLineId} | Type: ${lineTypeText} | Voltage: ${selectedLine ? selectedLine.voltage : 'N/A'}
                    </p>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${criticalRisks}</div>
                        <div class="metric-label">Critical Risks</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${highRisks}</div>
                        <div class="metric-label">High Risks</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${mediumRisks}</div>
                        <div class="metric-label">Medium Risks</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${lowRisks}</div>
                        <div class="metric-label">Low Risks</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${veryLowRisks}</div>
                        <div class="metric-label">Very Low Risks</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${avgRiskScore.toFixed(3)}</div>
                        <div class="metric-label">Average Risk Score</div>
                    </div>
                </div>
            `;
            
            content.innerHTML = riskContent;
            
            // Update high-risk vegetation section
            updateHighRiskVegetation();
        }

        // Update growth prediction
        function updateGrowthPrediction() {
            const content = document.getElementById('growth-prediction-content');
            const scheduleContent = document.getElementById('maintenance-schedule-content');
            
            if (vegetationData.length === 0) {
                // Check if this is due to urban/road area
                const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                const selectedLine = lines.find(l => l.id === selectedLineId);
                
                if (selectedLine) {
                    const context = analyzeGeographicalContext(selectedLine);
                    if (!context.hasVegetation) {
                        content.innerHTML = `
                            <div class="no-data-message">
                                <p>üèôÔ∏è <strong>No Growth Prediction Needed</strong></p>
                                <p>This line is in an urban/road area with no vegetation interference.</p>
                                <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                    Line: ${selectedLine.name} | Type: ${currentLineType === 'transmission' ? 'Transmission' : 'Distribution'}
                                </p>
                            </div>
                        `;
                        scheduleContent.innerHTML = `
                            <div class="no-data-message">
                                <p>‚úÖ <strong>No Maintenance Required</strong></p>
                                <p>No vegetation maintenance schedule needed for this location.</p>
                                <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                    Line: ${selectedLine.name} | Type: ${currentLineType === 'transmission' ? 'Transmission' : 'Distribution'}
                                </p>
                            </div>
                        `;
                    } else {
                        // Don't override the clear message if it exists
                        const currentContent = content.innerHTML;
                        if (!currentContent.includes('No Growth Prediction Available')) {
                            content.innerHTML = `
                                <div class="no-data-message">
                                    <p>üìà <strong>No Growth Prediction Available</strong></p>
                                    <p>Click "Report Generator" to analyze growth for ${selectedLine.name}.</p>
                                    <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                        This will generate a comprehensive growth prediction for the selected line.
                                    </p>
                                </div>
                            `;
                        }
                        const currentScheduleContent = scheduleContent.innerHTML;
                        if (!currentScheduleContent.includes('No Maintenance Schedule Available')) {
                            scheduleContent.innerHTML = `
                                <div class="no-data-message">
                                    <p>üìÖ <strong>No Maintenance Schedule Available</strong></p>
                                    <p>Click "Report Generator" to generate maintenance schedule for ${selectedLine.name}.</p>
                                    <p style="font-size: 12px; margin-top: 10px; color: #7f8c8d;">
                                        This will create a prioritized maintenance schedule based on vegetation analysis.
                                    </p>
                                </div>
                            `;
                        }
                    }
                } else {
                    content.innerHTML = `
                        <div class="no-data-message">
                            <p>üìà <strong>No Line Selected</strong></p>
                            <p>Please select a power line first, then click "Report Generator" to analyze growth.</p>
                        </div>
                    `;
                    scheduleContent.innerHTML = `
                        <div class="no-data-message">
                            <p>üìÖ <strong>No Line Selected</strong></p>
                            <p>Please select a power line first, then click "Report Generator" to generate maintenance schedule.</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Get the selected line for the report header
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const selectedLine = lines.find(l => l.id === selectedLineId);
            const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
            
            // Calculate growth statistics
            const avgGrowthRate = vegetationData.reduce((sum, v) => sum + v.growthRate, 0) / vegetationData.length;
            const criticalGrowth = vegetationData.filter(v => v.riskLevel === 'Critical' && v.growthRate > 0.3).length;
            
            // Create growth prediction content with line-specific header
            const growthContent = `
                <div style="background: #d1ecf1; padding: 10px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #17a2b8;">
                    <h4 style="margin: 0; color: #0c5460;">üìà Growth Prediction for: ${selectedLine ? selectedLine.name : 'Selected Line'}</h4>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #0c5460;">
                        Line ID: ${selectedLineId} | Type: ${lineTypeText} | Voltage: ${selectedLine ? selectedLine.voltage : 'N/A'}
                    </p>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${avgGrowthRate.toFixed(2)}</div>
                        <div class="metric-label">Average Growth Rate</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${criticalGrowth}</div>
                        <div class="metric-label">Critical Growth Points</div>
                    </div>
                </div>
            `;
            
            content.innerHTML = growthContent;
            
            // Maintenance schedule
            const immediate = vegetationData.filter(v => v.priority === 'Immediate').length;
            const high = vegetationData.filter(v => v.priority === 'High').length;
            const medium = vegetationData.filter(v => v.priority === 'Medium').length;
            const low = vegetationData.filter(v => v.priority === 'Low').length;
            const monitor = vegetationData.filter(v => v.priority === 'Monitor').length;
            
            const scheduleHeader = `
                <div style="background: #d4edda; padding: 10px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #28a745;">
                    <h4 style="margin: 0; color: #155724;">üìÖ Maintenance Schedule for: ${selectedLine ? selectedLine.name : 'Selected Line'}</h4>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #155724;">
                        Line ID: ${selectedLineId} | Type: ${lineTypeText} | Voltage: ${selectedLine ? selectedLine.voltage : 'N/A'}
                    </p>
                </div>
            `;
            
            const scheduleMetrics = `
                <div class="metric">
                    <div>
                        <div class="metric-value">${immediate}</div>
                        <div class="metric-label">Immediate (1 week)</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${high}</div>
                        <div class="metric-label">High (1 month)</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${medium}</div>
                        <div class="metric-label">Medium (3 months)</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${low}</div>
                        <div class="metric-label">Low (6 months)</div>
                    </div>
                </div>
                <div class="metric">
                    <div>
                        <div class="metric-value">${monitor}</div>
                        <div class="metric-label">Monitor (1 year)</div>
                    </div>
                </div>
            `;
            
            scheduleContent.innerHTML = scheduleHeader + scheduleMetrics;
        }

        // Initialize charts
        function initializeCharts() {
            // Risk distribution chart
            const riskCtx = document.getElementById('riskDistributionChart').getContext('2d');
            charts.riskDistribution = new Chart(riskCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Critical', 'High', 'Medium', 'Low'],
                    datasets: [{
                        data: [5, 15, 35, 45],
                        backgroundColor: ['#e74c3c', '#f39c12', '#f1c40f', '#27ae60']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });

            // Vegetation type chart
            const typeCtx = document.getElementById('vegetationTypeChart').getContext('2d');
            charts.vegetationType = new Chart(typeCtx, {
                type: 'bar',
                data: {
                    labels: ['Oak', 'Pine', 'Eucalyptus', 'Maple', 'Cypress', 'Redwood'],
                    datasets: [{
                        label: 'Count',
                        data: [25, 20, 15, 18, 12, 10],
                        backgroundColor: '#3498db'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });

            // Growth trend chart
            const growthCtx = document.getElementById('growthTrendChart').getContext('2d');
            charts.growthTrend = new Chart(growthCtx, {
                type: 'line',
                data: {
                    labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
                    datasets: [{
                        label: 'Growth Rate',
                        data: [0.2, 0.25, 0.3, 0.35, 0.4, 0.45],
                        borderColor: '#27ae60',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }

        // Update overview metrics
        function updateOverviewMetrics() {
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
            
            // Update total lines count for current type
            document.getElementById('total-lines').textContent = lines.length;
            
            // Update label to reflect current line type
            const metricLabel = document.getElementById('total-lines-label');
            if (metricLabel) {
                metricLabel.textContent = `Total ${lineTypeText} Lines`;
            }
            
            // Calculate vegetation data based on current line type and selected line
            let totalVegetation = 0;
            let criticalRisks = 0;
            let highRisks = 0;
            let avgRisk = 0;
            
            if (selectedLineId && vegetationData.length > 0) {
                totalVegetation = vegetationData.length;
                criticalRisks = vegetationData.filter(v => v.riskLevel === 'Critical').length;
                highRisks = vegetationData.filter(v => v.riskLevel === 'High').length;
                avgRisk = vegetationData.reduce((sum, v) => sum + v.riskScore, 0) / vegetationData.length;
            } else if (selectedLineId) {
                // Check if selected line is in urban area (no vegetation)
                const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                const selectedLine = lines.find(l => l.id === selectedLineId);
                if (selectedLine) {
                    const context = analyzeGeographicalContext(selectedLine);
                    if (!context.hasVegetation) {
                        totalVegetation = 0;
                        criticalRisks = 0;
                        highRisks = 0;
                        avgRisk = 0;
                    } else {
                        // Default values for areas with potential vegetation
                        totalVegetation = currentLineType === 'transmission' ? 1247 : 856;
                        criticalRisks = currentLineType === 'transmission' ? 23 : 15;
                        highRisks = currentLineType === 'transmission' ? 45 : 32;
                        avgRisk = currentLineType === 'transmission' ? 0.45 : 0.38;
                    }
                } else {
                    // Default values when no specific line is selected
                    totalVegetation = currentLineType === 'transmission' ? 1247 : 856;
                    criticalRisks = currentLineType === 'transmission' ? 23 : 15;
                    highRisks = currentLineType === 'transmission' ? 45 : 32;
                    avgRisk = currentLineType === 'transmission' ? 0.45 : 0.38;
                }
            } else {
                // Default values when no specific line is selected
                totalVegetation = currentLineType === 'transmission' ? 1247 : 856;
                criticalRisks = currentLineType === 'transmission' ? 23 : 15;
                highRisks = currentLineType === 'transmission' ? 45 : 32;
                avgRisk = currentLineType === 'transmission' ? 0.45 : 0.38;
            }
            
            document.getElementById('total-vegetation').textContent = totalVegetation.toLocaleString();
            document.getElementById('critical-risks').textContent = criticalRisks;
            document.getElementById('avg-risk').textContent = avgRisk.toFixed(2);
        }

        // Update map
        function updateMap() {
            console.log('updateMap called');
            
            // Check if Leaflet is available
            if (typeof L === 'undefined') {
                console.error('Leaflet is not loaded!');
                return;
            }
            
            // Initialize map if it doesn't exist
            if (!map) {
                console.log('Initializing new map');
                const mapContainer = document.getElementById('interactive-map');
                if (!mapContainer) {
                    console.error('Map container not found!');
                    return;
                }
                
                map = L.map('interactive-map', {
                    zoomControl: true,
                    scrollWheelZoom: true,
                    doubleClickZoom: true,
                    boxZoom: true,
                    keyboard: true,
                    dragging: true
                }).setView([37.7749, -122.4194], 10);
                
                // Add tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);
                
                // Add zoom controls with custom positioning
                L.control.zoom({
                    position: 'topright'
                }).addTo(map);
                
                // Add custom zoom controls
                const customZoomControl = L.Control.extend({
                    options: {
                        position: 'topleft'
                    },
                    
                    onAdd: function(map) {
                        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-zoom-control');
                        
                        const zoomInBtn = L.DomUtil.create('a', 'leaflet-control-zoom-in', container);
                        zoomInBtn.innerHTML = '+';
                        zoomInBtn.title = 'Zoom In';
                        zoomInBtn.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; font-weight: bold; font-size: 18px;';
                        zoomInBtn.onclick = function() {
                            map.zoomIn();
                        };
                        
                        const zoomOutBtn = L.DomUtil.create('a', 'leaflet-control-zoom-out', container);
                        zoomOutBtn.innerHTML = '‚àí';
                        zoomOutBtn.title = 'Zoom Out';
                        zoomOutBtn.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; font-weight: bold; font-size: 18px;';
                        zoomOutBtn.onclick = function() {
                            map.zoomOut();
                        };
                        
                        const resetViewBtn = L.DomUtil.create('a', 'leaflet-control-reset-view', container);
                        resetViewBtn.innerHTML = '‚åÇ';
                        resetViewBtn.title = 'Reset View';
                        resetViewBtn.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; font-weight: bold; font-size: 18px; margin-top: 5px;';
                        resetViewBtn.onclick = function() {
                            resetMapView();
                        };
                        
                        return container;
                    }
                });
                
                map.addControl(new customZoomControl());
                
                // Add map event listeners
                map.on('zoomend', function() {
                    console.log('Map zoom level:', map.getZoom());
                });
                
                map.on('moveend', function() {
                    console.log('Map center:', map.getCenter());
                });
                
                // Mark map as loaded when tiles are loaded
                map.on('tileload', function() {
                    if (!map._loaded) {
                        map._loaded = true;
                        console.log('Map fully loaded (tiles loaded)');
                    }
                });
                
                // Mark map as loaded after a short delay as fallback
                setTimeout(() => {
                    if (!map._loaded) {
                        map._loaded = true;
                        console.log('Map marked as loaded (timeout fallback)');
                    }
                }, 1000);
                
                console.log('Map initialized successfully');
            }
            
            // Clear existing layers
            clearMapLayers();
            console.log('Map layers cleared');
            
            // Add tile layer back
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            if (selectedLineId) {
                const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                const line = lines.find(l => l.id === selectedLineId);
                
                if (line) {
                    console.log('Selected line:', line);
                    
                    // Use detailed coordinates if available (from KML), otherwise use start/end points
                    let lineCoords;
                    if (line.coordinates && line.coordinates.length > 0) {
                        lineCoords = line.coordinates.map(coord => [coord.lat, coord.lon]);
                    } else {
                        lineCoords = [[line.startLat, line.startLon], [line.endLat, line.endLon]];
                    }
                    console.log('Line coordinates:', lineCoords);
                    
                    // Check if this is a KML imported line
                    const isKMLLine = uploadedKMLData && uploadedKMLData.lines.some(kmlLine => kmlLine.id === selectedLineId);
                    
                    // Add power line with appropriate styling
                    const lineColor = isKMLLine ? '#e74c3c' : (currentLineType === 'transmission' ? '#e74c3c' : '#3498db');
                    const lineWeight = isKMLLine ? 10 : 6;
                    const lineOpacity = isKMLLine ? 1.0 : 0.8;
                    const dashArray = isKMLLine ? '8, 8' : null;
                    
                    const powerLine = L.polyline(lineCoords, {
                        color: lineColor,
                        weight: lineWeight,
                        opacity: lineOpacity,
                        dashArray: dashArray
                    }).addTo(map);
                    console.log('Power line added to map');
                    
                    // Add popup to the line
                    powerLine.bindPopup(`
                        <div style="min-width: 200px;">
                            <h4 style="margin: 0 0 10px 0; color: ${lineColor};">${line.name}</h4>
                            <p><strong>ID:</strong> ${line.id}</p>
                            <p><strong>Voltage:</strong> ${line.voltage}</p>
                            <p><strong>Type:</strong> ${currentLineType === 'transmission' ? 'Transmission' : 'Distribution'}</p>
                            <p><strong>Region:</strong> ${line.region}</p>
                            <p><strong>Length:</strong> ${line.length.toFixed(1)} km</p>
                            <p><strong>Status:</strong> ${line.status}</p>
                            ${isKMLLine ? '<p style="margin-top: 10px; font-size: 12px; color: #e74c3c;">üìç KML Imported Line</p>' : ''}
                        </div>
                    `);
                    
                    // Add start and end markers for selected line
                    if (lineCoords.length > 0) {
                        // Start marker
                        L.marker(lineCoords[0], {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="background-color: ${lineColor}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        }).addTo(map).bindPopup(`<strong>Start:</strong> ${line.name}`);
                        
                        // End marker
                        L.marker(lineCoords[lineCoords.length - 1], {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="background-color: ${lineColor}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>`,
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        }).addTo(map).bindPopup(`<strong>End:</strong> ${line.name}`);
                    }
                    
                    // Fit map to the selected line
                    if (lineCoords.length > 0) {
                        const bounds = L.latLngBounds(lineCoords);
                        map.fitBounds(bounds, { padding: [20, 20] });
                    }
                    
                    // Add vegetation points if data is available
                    if (vegetationData.length > 0) {
                        console.log('Adding vegetation points:', vegetationData.length);
                        const vegetationPoints = [];
                        
                        vegetationData.forEach((veg, index) => {
                            // Calculate position along the line with some offset
                            const progress = index / (vegetationData.length - 1);
                            let lat, lon;
                            
                            if (line.coordinates && line.coordinates.length > 0) {
                                // Use actual line coordinates for more accurate positioning
                                const coordIndex = Math.floor(progress * (line.coordinates.length - 1));
                                const coord = line.coordinates[coordIndex];
                                lat = coord.lat + (Math.random() - 0.5) * 0.01;
                                lon = coord.lon + (Math.random() - 0.5) * 0.01;
                            } else {
                                // Fallback to start/end point calculation
                                lat = line.startLat + (line.endLat - line.startLat) * progress + (Math.random() - 0.5) * 0.02;
                                lon = line.startLon + (line.endLon - line.startLon) * progress + (Math.random() - 0.5) * 0.02;
                            }
                            
                            // Set color based on risk level
                            const color = veg.riskLevel === 'Critical' ? '#e74c3c' :
                                        veg.riskLevel === 'High' ? '#f39c12' :
                                        veg.riskLevel === 'Medium' ? '#f1c40f' :
                                        veg.riskLevel === 'Low' ? '#27ae60' : '#9b59b6';
                            
                            // Create circle marker
                            const marker = L.circleMarker([lat, lon], {
                                radius: Math.max(4, Math.min(veg.height / 3, 12)),
                                color: color,
                                fillColor: color,
                                fillOpacity: 0.8,
                                weight: 2
                            }).addTo(map);
                            
                            // Add popup to vegetation point
                            marker.bindPopup(`
                                <div style="min-width: 200px;">
                                    <h4 style="margin: 0 0 10px 0; color: ${color};">Vegetation Point</h4>
                                    <p><strong>Type:</strong> ${veg.type}</p>
                                    <p><strong>Height:</strong> ${veg.height.toFixed(1)} m</p>
                                    <p><strong>Distance:</strong> ${veg.distance.toFixed(1)} m</p>
                                    <p><strong>Risk Level:</strong> <span style="color: ${color};">${veg.riskLevel}</span></p>
                                    <p><strong>Risk Score:</strong> ${veg.riskScore.toFixed(2)}</p>
                                    <p><strong>Priority:</strong> ${veg.priority}</p>
                                    <p><strong>Estimated Cost:</strong> $${veg.estimatedCost.toLocaleString()}</p>
                                </div>
                            `);
                            
                            vegetationPoints.push(marker);
                        });
                    }
                }
            } else {
                // No line selected - show overview of all lines
                const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                
                // If KML data is available, show all KML lines
                if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                    showAllKMLLines();
                } else if (lines.length > 0) {
                const bounds = L.latLngBounds();
                
                    lines.forEach(line => {
                        let lineCoords;
                        if (line.coordinates && line.coordinates.length > 0) {
                            lineCoords = line.coordinates.map(coord => [coord.lat, coord.lon]);
                        } else {
                            lineCoords = [[line.startLat, line.startLon], [line.endLat, line.endLon]];
                        }
                        
                        // Add line to bounds
                        lineCoords.forEach(coord => bounds.extend(coord));
                        
                        // Add thin line for overview
                        const lineColor = currentLineType === 'transmission' ? '#e74c3c' : '#3498db';
                        L.polyline(lineCoords, {
                        color: lineColor,
                            weight: 2,
                        opacity: 0.6
                    }).addTo(map);
                    });
                    
                    // Fit map to show all lines
                if (!bounds.isEmpty()) {
                    map.fitBounds(bounds, { padding: [20, 20] });
                    }
                }
            }
        }

        // Show tab
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Update map if on map tab
            if (tabName === 'map') {
                setTimeout(() => {
                    console.log('Map tab activated');
                    // Force map refresh and ensure it's properly displayed
                    if (map) {
                        map.invalidateSize();
                        console.log('Map invalidated size');
                    } else {
                        console.log('Creating new map for map tab');
                        updateMap();
                    }
                    // Always update map content
                    updateMap();
                }, 200);
            }
        }

        // Generate report
        function generateRiskReport() {
            if (!selectedLineId) {
                showNotification('Please select a power line first', 'warning');
                return;
            }
            
            // Get the current lines (either from KML or default data)
            let lines;
            if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                // Use KML data if available
                lines = uploadedKMLData.lines;
                console.log('üîç Using KML data for report generation');
            } else {
                // Use default transmission/distribution lines
                lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                console.log('üîç Using default data for report generation');
            }
            
            const selectedLine = lines.find(l => l.id === selectedLineId);
            
            if (!selectedLine) {
                showNotification('Selected line not found', 'error');
                return;
            }
            
            showNotification(`Generating vegetation analysis report for ${selectedLine.name}...`, 'info');
            
            // Load vegetation data and update all analysis sections
            setTimeout(async () => {
                try {
                    // Load vegetation data for the specific line
                    await loadVegetationData(selectedLineId);
                    
                    // Show success message with line details
                    const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
                    showNotification(`${lineTypeText} line report generated successfully for ${selectedLine.name}!`, 'success');
                    
                    // Update the vegetation analysis content to show it's for the specific line
                    const vegetationContent = document.getElementById('vegetation-analysis-content');
                    if (vegetationContent && vegetationData.length > 0) {
                        const existingContent = vegetationContent.innerHTML;
                        // Only add header if it doesn't already exist
                        if (!existingContent.includes('Analysis Report for:')) {
                            const lineHeader = `
                                <div style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #007bff;">
                                    <h4 style="margin: 0; color: #007bff;">üìä Analysis Report for: ${selectedLine.name}</h4>
                                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #6c757d;">
                                        Line ID: ${selectedLineId} | Type: ${lineTypeText} | Voltage: ${selectedLine.voltage}
                                    </p>
                                </div>
                            `;
                            vegetationContent.innerHTML = lineHeader + existingContent;
                        }
                    }
                    
                } catch (error) {
                    console.error('Error generating report:', error);
                    
                    // Try fallback approach
                    try {
                        console.log('Attempting fallback vegetation generation...');
                        vegetationData = generateVegetationData(selectedLineId);
                        
                        if (vegetationData && vegetationData.length > 0) {
                updateVegetationAnalysis();
                updateRiskAssessment();
                updateGrowthPrediction();
                
                            const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
                            showNotification(`${lineTypeText} line report generated successfully for ${selectedLine.name}! (Fallback mode)`, 'success');
                        } else {
                            showNotification('No vegetation data available for this line.', 'info');
                        }
                    } catch (fallbackError) {
                        console.error('Fallback also failed:', fallbackError);
                        showNotification('Error generating report. Please try again.', 'error');
                    }
                }
            }, 1500);
        }

        // Generate PDF report
        async function generatePDFReport() {
            if (!selectedLineId) {
                showNotification('Please select a power line first', 'warning');
                return;
            }
            
            if (vegetationData.length === 0) {
                showNotification('No report data available. Please generate a report first.', 'warning');
                return;
            }
            
            showNotification('Generating PDF...', 'info');
            
            try {
                // First capture the map if available
                if (map) {
                    showNotification('Capturing map for PDF...', 'info');
                    try {
                        window.capturedMapImage = await captureMapForPDF();
                        showNotification('Map captured successfully!', 'success');
                    } catch (error) {
                        console.log('Map capture failed, continuing without map:', error);
                        window.capturedMapImage = null;
                    }
                }
            
            // Generate a proper PDF using jsPDF library
            setTimeout(() => {
                try {
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const lineTypeText = currentLineType === 'transmission' ? 'transmission' : 'distribution';
                    const filename = `${lineTypeText}_report_${selectedLineId}_${timestamp}.pdf`;
                    
                    // Create PDF using jsPDF
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Add content to PDF
                    generatePDFContent(doc, lineTypeText);
                    
                    // Save the PDF
                    doc.save(filename);
                    
                    showNotification('PDF exported successfully!', 'success');
                } catch (error) {
                    showNotification('Error generating PDF: ' + error.message, 'error');
                }
            }, 2000);
                
            } catch (error) {
                showNotification('Error in PDF generation: ' + error.message, 'error');
            }
        }
        
        // Generate PDF content using jsPDF
        function generatePDFContent(doc, lineTypeText) {
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const line = lines.find(l => l.id === selectedLineId);
            
            // Calculate statistics
            const criticalRisks = vegetationData.filter(v => v.riskLevel === 'Critical').length;
            const highRisks = vegetationData.filter(v => v.riskLevel === 'High').length;
            const mediumRisks = vegetationData.filter(v => v.riskLevel === 'Medium').length;
            const lowRisks = vegetationData.filter(v => v.riskLevel === 'Low').length;
            const avgRiskScore = vegetationData.reduce((sum, v) => sum + v.riskScore, 0) / vegetationData.length;
            const totalCost = vegetationData.reduce((sum, v) => sum + v.estimatedCost, 0);
            
            // Set font and starting position
            doc.setFontSize(20);
            doc.setFont('helvetica', 'bold');
            doc.text('Vegetation Management Report', 105, 20, { align: 'center' });
            
            // Add report details
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text(`Report Generated: ${new Date().toLocaleString()}`, 20, 40);
            doc.text(`${lineTypeText.charAt(0).toUpperCase() + lineTypeText.slice(1)} Line Report`, 20, 50);
            doc.text(`Line ID: ${selectedLineId}`, 20, 60);
            doc.text(`Line Name: ${line.name}`, 20, 70);
            doc.text(`Voltage: ${line.voltage}`, 20, 80);
            doc.text(`Region: ${line.region}`, 20, 90);
            
            // Add statistics
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.text('Risk Analysis Summary', 20, 110);
            
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text(`Total Vegetation Points: ${vegetationData.length}`, 20, 125);
            doc.text(`Critical Risks: ${criticalRisks}`, 20, 135);
            doc.text(`High Risks: ${highRisks}`, 20, 145);
            doc.text(`Medium Risks: ${mediumRisks}`, 20, 155);
            doc.text(`Low Risks: ${lowRisks}`, 20, 165);
            doc.text(`Average Risk Score: ${avgRiskScore.toFixed(3)}`, 20, 175);
            doc.text(`Total Estimated Cost: $${totalCost.toFixed(0)}`, 20, 185);
            
            // Add vegetation details if available
            if (vegetationData.length > 0) {
                doc.setFontSize(14);
                doc.setFont('helvetica', 'bold');
                doc.text('Vegetation Details', 20, 205);
                
                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                let yPos = 220;
                vegetationData.slice(0, 10).forEach((veg, index) => {
                    if (yPos > 250) {
                        doc.addPage();
                        yPos = 20;
                    }
                    doc.text(`${index + 1}. ${veg.type} - Risk: ${veg.riskLevel} (${veg.riskScore.toFixed(2)})`, 20, yPos);
                    yPos += 10;
                });
                
                if (vegetationData.length > 10) {
                    doc.text(`... and ${vegetationData.length - 10} more vegetation points`, 20, yPos + 10);
                }
            }
            
            // Add map image if available
            try {
                if (map && selectedLineId) {
                    doc.addPage();
                    doc.setFontSize(16);
                    doc.setFont('helvetica', 'bold');
                    doc.text('Interactive Map View', 20, 20);
                    
                    // Try to add the actual captured map image
                    if (window.capturedMapImage) {
                        try {
                            // Add the captured map image
                    const mapWidth = 170;
                            const mapHeight = 120;
                    const mapX = 20;
                    const mapY = 40;
                    
                            doc.addImage(window.capturedMapImage, 'PNG', mapX, mapY, mapWidth, mapHeight);
                    
                    // Add map title
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.text('Geographic Overview', mapX + mapWidth/2, mapY - 5, { align: 'center' });
                    
                    // Add map legend
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.text('Map Legend:', mapX, mapY + mapHeight + 20);
                                doc.text('‚Ä¢ Red: Critical Risk (<10m)', mapX, mapY + mapHeight + 30);
            doc.text('‚Ä¢ Orange: High Risk (10-20m)', mapX, mapY + mapHeight + 40);
            doc.text('‚Ä¢ Yellow: Medium Risk (20-30m)', mapX, mapY + mapHeight + 50);
            doc.text('‚Ä¢ Green: Low Risk (30-50m)', mapX, mapY + mapHeight + 60);
            doc.text('‚Ä¢ Purple: Very Low Risk (>50m)', mapX, mapY + mapHeight + 70);
                        } catch (imageError) {
                            console.log('Could not add map image to PDF:', imageError);
                            // Fallback to simple map representation
                            createSimpleMapRepresentation(doc, mapX, mapY, mapWidth, mapHeight);
                        }
                    } else {
                        // Fallback to simple map representation
                        const mapWidth = 170;
                        const mapHeight = 200;
                        const mapX = 20;
                        const mapY = 40;
                        createSimpleMapRepresentation(doc, mapX, mapY, mapWidth, mapHeight);
                    }
                    
                    // Add line information
                    const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
                    const line = lines.find(l => l.id === selectedLineId);
                    if (line) {
                        doc.setFontSize(12);
                        doc.setFont('helvetica', 'bold');
                        doc.text('Selected Line Information:', mapX, mapY + mapHeight + 80);
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'normal');
                        doc.text(`‚Ä¢ Name: ${line.name} (${line.id})`, mapX, mapY + mapHeight + 90);
                        doc.text(`‚Ä¢ Type: ${currentLineType === 'transmission' ? 'Transmission' : 'Distribution'}`, mapX, mapY + mapHeight + 100);
                        doc.text(`‚Ä¢ Voltage: ${line.voltage}`, mapX, mapY + mapHeight + 110);
                        doc.text(`‚Ä¢ Region: ${line.region}`, mapX, mapY + mapHeight + 120);
                        doc.text(`‚Ä¢ Length: ${line.length.toFixed(1)} km`, mapX, mapY + mapHeight + 130);
                        doc.text(`‚Ä¢ Vegetation Points: ${vegetationData.length}`, mapX, mapY + mapHeight + 140);
                        
                        // Add risk summary
                        if (vegetationData.length > 0) {
                            const criticalRisks = vegetationData.filter(v => v.riskLevel === 'Critical').length;
                            const highRisks = vegetationData.filter(v => v.riskLevel === 'High').length;
                            doc.text(`‚Ä¢ Critical Risks: ${criticalRisks}`, mapX, mapY + mapHeight + 150);
                            doc.text(`‚Ä¢ High Risks: ${highRisks}`, mapX, mapY + mapHeight + 160);
                        }
                    }
                }
            } catch (error) {
                console.log('Could not add map to PDF:', error);
            }
        }

        // Refresh data
        function refreshData() {
            if (!selectedLineId) {
                showNotification('Please select a power line first', 'warning');
                return;
            }
            
            if (vegetationData.length === 0) {
                showNotification('No report data to refresh. Please generate a report first.', 'warning');
                return;
            }
            
            showNotification('Refreshing report data...', 'info');
            
            setTimeout(() => {
                // Regenerate vegetation data and update all analysis sections
                loadVegetationData(selectedLineId);
                updateVegetationAnalysis();
                updateRiskAssessment();
                updateGrowthPrediction();
                updateMap(); // Update map with new vegetation points
                
                showNotification('Report data refreshed successfully!', 'success');
            }, 1000);
        }

        // Refresh map function
        function refreshMap() {
            console.log('Manual map refresh requested');
            if (map) {
                map.remove();
                map = null;
            }
            setTimeout(() => {
                updateMap();
                showNotification('Map refreshed successfully!', 'success');
            }, 100);
        }

        // Show notification
        function showNotification(message, type) {
            const notification = document.getElementById('notification');
          
        // Fallback data when backend is unavailable
        function generateFallbackVegetationData(lineId, lineData) {
            console.log('üîÑ Using fallback vegetation data for:', lineId);
            
            const vegetationTypes = ['Oak', 'Pine', 'Eucalyptus', 'Maple', 'Cypress'];
            const riskLevels = ['Low', 'Medium', 'High', 'Critical'];
            const healthStatuses = ['Healthy', 'Stressed', 'Diseased'];
            
            const vegetationData = [];
            const numVegetation = Math.floor(Math.random() * 8) + 3; // 3-10 items
            
            for (let i = 0; i < numVegetation; i++) {
                const distance = Math.random() * 50 + 5; // 5-55 meters
                const riskLevel = riskLevels[Math.floor(Math.random() * riskLevels.length)];
                const vegetationType = vegetationTypes[Math.floor(Math.random() * vegetationTypes.length)];
                const health = healthStatuses[Math.floor(Math.random() * healthStatuses.length)];
                
                vegetationData.push({
                    id: `veg_${lineId}_${i}`,
                    type: vegetationType,
                    distance: distance.toFixed(1),
                    height: (Math.random() * 20 + 5).toFixed(1),
                    risk_level: riskLevel,
                    risk_score: (Math.random() * 0.8 + 0.2).toFixed(2),
                    health: health,
                    priority: riskLevel === 'Critical' ? 'Immediate' : 
                             riskLevel === 'High' ? 'High' : 
                             riskLevel === 'Medium' ? 'Medium' : 'Low',
                    estimated_cost: Math.floor(Math.random() * 5000 + 500),
                    coordinates: {
                        lat: lineData.coordinates[0].lat + (Math.random() - 0.5) * 0.01,
                        lng: lineData.coordinates[0].lng + (Math.random() - 0.5) * 0.01
                    }
                });
            }
            
            return {
                vegetation_data: vegetationData,
                context: {
                    has_vegetation: true,
                    region_type: 'Mixed',
                    risk_assessment: {
                        critical_risks: vegetationData.filter(v => v.risk_level === 'Critical').length,
                        high_risks: vegetationData.filter(v => v.risk_level === 'High').length,
                        medium_risks: vegetationData.filter(v => v.risk_level === 'Medium').length,
                        low_risks: vegetationData.filter(v => v.risk_level === 'Low').length,
                        total_cost: vegetationData.reduce((sum, v) => sum + v.estimated_cost, 0)
                    }
                },
                message: 'Fallback data generated (backend unavailable)'
            };
        }
        
        // Override the API call function to use fallback data
        async function callPythonAPI(endpoint, data = null) {
            if (!isApiConnected) {
                console.log('‚ö†Ô∏è API not connected, using fallback data');
                if (endpoint === 'detect_vegetation' && data) {
                    return generateFallbackVegetationData(data.line_id, data);
                }
                return null;
            }
            
            // ... existing API call code ...
        }
          notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Update high-risk vegetation section
        function updateHighRiskVegetation() {
            const highRiskContent = document.getElementById('high-risk-vegetation');
            
            if (vegetationData.length === 0) {
                return;
            }
            
            // Get the selected line for the report header
            const lines = currentLineType === 'transmission' ? transmissionLines : distributionLines;
            const selectedLine = lines.find(l => l.id === selectedLineId);
            const lineTypeText = currentLineType === 'transmission' ? 'Transmission' : 'Distribution';
            
            // High-risk vegetation
            const highRiskVegetation = vegetationData.filter(v => v.riskLevel === 'Critical' || v.riskLevel === 'High');
            
            if (highRiskVegetation.length === 0) {
                highRiskContent.innerHTML = `
                    <div style="background: #d4edda; padding: 10px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #28a745;">
                        <h4 style="margin: 0; color: #155724;">‚úÖ High-Risk Vegetation for: ${selectedLine ? selectedLine.name : 'Selected Line'}</h4>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #155724;">
                            Line ID: ${selectedLineId} | Type: ${lineTypeText} | Voltage: ${selectedLine ? selectedLine.voltage : 'N/A'}
                        </p>
                    </div>
                    <div class="no-data-message">
                        <p>‚úÖ <strong>No High-Risk Vegetation Detected</strong></p>
                        <p>All vegetation in this area poses low to medium risk.</p>
                    </div>
                `;
            } else {
                const header = `
                    <div style="background: #f8d7da; padding: 10px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #dc3545;">
                        <h4 style="margin: 0; color: #721c24;">üö® High-Risk Vegetation for: ${selectedLine ? selectedLine.name : 'Selected Line'}</h4>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #721c24;">
                            Line ID: ${selectedLineId} | Type: ${lineTypeText} | Voltage: ${selectedLine ? selectedLine.voltage : 'N/A'}
                        </p>
                    </div>
                `;
                
                const riskItems = highRiskVegetation.map(veg => `
                    <div style="padding: 10px; margin: 5px 0; background: rgba(231, 76, 60, 0.1); border-radius: 5px; border-left: 3px solid #dc3545;">
                        <strong>${veg.id}</strong> - ${veg.type}<br>
                        Height: ${veg.height.toFixed(1)}m | Distance: ${veg.distance.toFixed(1)}m<br>
                        Risk: <span class="risk-level risk-${veg.riskLevel.toLowerCase()}">${veg.riskLevel}</span> | 
                        Priority: ${veg.priority} | Cost: $${veg.estimatedCost.toFixed(0)}
                    </div>
                `).join('');
                
                highRiskContent.innerHTML = header + riskItems;
            }
        }

        // Function to show all KML lines when no specific line is selected
        function showAllKMLLines() {
            if (!map || !uploadedKMLData || !uploadedKMLData.lines) return;
            
            console.log('üó∫Ô∏è Showing all KML lines...');
            
            // Clear existing layers
            clearMapLayers();
            
            // Add tile layer back
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            const bounds = L.latLngBounds();
            
            uploadedKMLData.lines.forEach((line, index) => {
                let lineCoords;
                if (line.coordinates && line.coordinates.length > 0) {
                    lineCoords = line.coordinates.map(coord => [coord.lat, coord.lon]);
                } else {
                    lineCoords = [[line.startLat, line.startLon], [line.endLat, line.endLon]];
                }
                
                // Add coordinates to bounds
                lineCoords.forEach(coord => bounds.extend(coord));
                
                // Create line with red color for KML lines
                const powerLine = L.polyline(lineCoords, {
                    color: '#e74c3c',
                    weight: 4,
                    opacity: 0.7
                }).addTo(map);
                
                // Add popup to the line
                powerLine.bindPopup(`
                    <div style="min-width: 200px;">
                        <h4 style="margin: 0 0 10px 0; color: #e74c3c;">${line.name}</h4>
                        <p><strong>ID:</strong> ${line.id}</p>
                        <p><strong>Voltage:</strong> ${line.voltage}</p>
                        <p><strong>Type:</strong> ${currentLineType === 'transmission' ? 'Transmission' : 'Distribution'}</p>
                        <p><strong>Region:</strong> ${line.region}</p>
                        <p><strong>Length:</strong> ${line.length.toFixed(1)} km</p>
                        <p style="margin-top: 10px; font-size: 12px; color: #e74c3c;">
                            üìç KML Imported Line
                        </p>
                    </div>
                `);
            });
            
            // Fit map to show all KML lines
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: [20, 20] });
                console.log(`‚úÖ Showing ${uploadedKMLData.lines.length} KML lines`);
            }
        }

        // Function to refresh map view
        function refreshMapView() {
            console.log('üîÑ Refreshing map view...');
            
            if (uploadedKMLData && uploadedKMLData.lines && uploadedKMLData.lines.length > 0) {
                if (selectedLineId) {
                    // If a line is selected, update the map for that specific line
                    updateMap();
                } else {
                    // If no line is selected, show all KML lines
                    showAllKMLLines();
                }
                showNotification('Map view refreshed successfully!', 'success');
            } else {
                // No KML data available, just update the map
                updateMap();
                showNotification('Map view refreshed!', 'info');
            }
        }

        // Function to clear KML data
        function clearKMLData() {
            console.log('üóëÔ∏è Clearing KML data...');
            
            // Clear uploaded KML data
            uploadedKMLData = null;
            
            // Reset to default data
            loadTransmissionData();
            loadDistributionData();
            
            // Update UI
            document.getElementById('line-type-select').value = 'transmission';
            updateVoltageOptions();
            populateLineSelector();
            updateOverviewMetrics();
            
            // Clear file info
            document.getElementById('kml-upload-status').textContent = 'üìÅ No KML file uploaded';
            document.getElementById('kml-file-info').style.display = 'none';
            document.getElementById('kml-file-details').innerHTML = '';
            
            // Clear current selection
            selectedLineId = null;
            document.getElementById('line-details').style.display = 'none';
            
            // Update map to show default view
            setTimeout(() => {
                updateMap();
            }, 100);
            
            showNotification('KML data cleared. Returned to default view.', 'info');
        }

        // Function to export map as image
        function exportMapImage() {
            if (!map) {
                showNotification('Map not available', 'error');
                return;
            }
            
            try {
                // Wait for map to be fully rendered
                setTimeout(() => {
                    // Use html2canvas to capture the map container
                    const mapContainer = document.getElementById('map');
                    
                    if (!mapContainer) {
                        showNotification('Map container not found', 'error');
                        return;
                    }
                    
                    // Show loading message
                    showNotification('Capturing map...', 'info');
                    
                    // Use html2canvas to capture the map
                    html2canvas(mapContainer, {
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: '#ffffff',
                        scale: 2, // Higher quality
                        logging: false,
                        width: mapContainer.offsetWidth,
                        height: mapContainer.offsetHeight,
                        onclone: function(clonedDoc) {
                            // Ensure the cloned map has all the data
                            const clonedMap = clonedDoc.getElementById('map');
                            if (clonedMap) {
                                // Force a map refresh in the clone
                                clonedMap.style.overflow = 'visible';
                            }
                        }
                    }).then(canvas => {
                        // Convert canvas to blob
                        canvas.toBlob(function(blob) {
                            // Create download link
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `vegetation_map_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            showNotification('Map exported successfully!', 'success');
                        }, 'image/png', 1.0);
                    }).catch(error => {
                        console.error('Map capture error:', error);
                        showNotification('Failed to capture map. Trying alternative method...', 'warning');
                        
                        // Fallback: Try to capture using Leaflet's built-in method
                        try {
                            // Force map to render all tiles
                            map.invalidateSize();
                            
                            // Wait a bit for tiles to load
                            setTimeout(() => {
                                // Use Leaflet's built-in export method if available
                                if (map.exportImage) {
                                    map.exportImage().then(function(dataUrl) {
                                        const a = document.createElement('a');
                                        a.href = dataUrl;
                                        a.download = `vegetation_map_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        showNotification('Map exported using fallback method!', 'success');
                                    });
                                } else {
                                    // Last resort: manual canvas capture
                                    captureMapManually();
                                }
                            }, 2000);
                        } catch (fallbackError) {
                            console.error('Fallback capture error:', fallbackError);
                            showNotification('Map export failed. Please try again.', 'error');
                        }
                    });
                }, 1000); // Wait 1 second for map to be ready
                
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export failed: ' + error.message, 'error');
            }
        }
        
        // Manual map capture as fallback
        function captureMapManually() {
            try {
                const mapContainer = document.getElementById('map');
                if (!mapContainer) return;
                
                // Create a canvas element
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size
                canvas.width = mapContainer.offsetWidth;
                canvas.height = mapContainer.offsetHeight;
                
                // Fill with white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add map title
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Vegetation Management Map', canvas.width / 2, 30);
                
                // Add timestamp
                ctx.font = '12px Arial';
                ctx.fillText(`Generated: ${new Date().toLocaleString()}`, canvas.width / 2, 50);
                
                // Add KML info if available
                if (uploadedKMLData && uploadedKMLData.lines) {
                    ctx.fillText(`KML Lines: ${uploadedKMLData.totalLines}`, canvas.width / 2, 70);
                    ctx.fillText(`Coordinates: ${uploadedKMLData.totalCoordinates}`, canvas.width / 2, 90);
                }
                
                // Add note about map content
                ctx.font = '10px Arial';
                ctx.fillStyle = '#666666';
                ctx.fillText('Note: This is a simplified export. Open the HTML file for full interactive map.', canvas.width / 2, canvas.height - 20);
                
                // Convert to blob and download
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `vegetation_map_simplified_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showNotification('Simplified map exported!', 'success');
                }, 'image/png', 1.0);
                
            } catch (error) {
                console.error('Manual capture error:', error);
                showNotification('Manual capture failed', 'error');
            }
        }
        
        // Capture map for PDF inclusion
        async function captureMapForPDF() {
            return new Promise((resolve, reject) => {
                try {
                    if (!map) {
                        reject(new Error('Map not available'));
                        return;
                    }
                    
                    const mapContainer = document.getElementById('map');
                    if (!mapContainer) {
                        reject(new Error('Map container not found'));
                        return;
                    }
                    
                    // Force map to render all tiles
                    map.invalidateSize();
                    
                    // Wait for tiles to load
                    setTimeout(() => {
                        html2canvas(mapContainer, {
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: '#ffffff',
                            scale: 1,
                            logging: false,
                            width: mapContainer.offsetWidth,
                            height: mapContainer.offsetHeight
                        }).then(canvas => {
                            // Convert to data URL
                            const dataUrl = canvas.toDataURL('image/png');
                            resolve(dataUrl);
                        }).catch(error => {
                            console.error('Map capture for PDF failed:', error);
                            reject(error);
                        });
                    }, 2000);
                    
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Create simple map representation for PDF fallback
        function createSimpleMapRepresentation(doc, mapX, mapY, mapWidth, mapHeight) {
            // Draw map border and background
            doc.setDrawColor(200, 200, 200);
            doc.setFillColor(240, 240, 240);
            doc.rect(mapX, mapY, mapWidth, mapHeight, 'F');
            doc.rect(mapX, mapY, mapWidth, mapHeight);
            
            // Add map title
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('Geographic Overview', mapX + mapWidth/2, mapY - 5, { align: 'center' });
            
            // Add map legend
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text('Map Legend:', mapX, mapY + mapHeight + 20);
            doc.text('‚Ä¢ Red: Critical Risk (<10m)', mapX, mapY + mapHeight + 30);
            doc.text('‚Ä¢ Orange: High Risk (10-20m)', mapX, mapY + mapHeight + 40);
            doc.text('‚Ä¢ Yellow: Medium Risk (20-30m)', mapX, mapY + mapHeight + 50);
            doc.text('‚Ä¢ Green: Low Risk (30-50m)', mapX, mapY + mapHeight + 60);
            doc.text('‚Ä¢ Purple: Very Low Risk (>50m)', mapX, mapY + mapHeight + 70);
        }
    </script>
</body>
</html> 